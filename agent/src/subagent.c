/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/config_api.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <signal.h>

/*
 * include our object headers
 */
#include "queue/QueueTable.h"
#include "exchange/ExchangeTable.h"
#include "vhost/VhostTable.h"
#include "system/System.h"
#include "acl/Acl.h"
#include "ha/HaBroker.h"
#include "agent/Agent.h"
#include "broker/Broker.h"
#include "cluster/Cluster.h"
#include "memory/Memory.h"
#include "state/ManagementSetupState.h"
#include "binding/BindingTable.h"
#include "session/SessionTable.h"
#include "subscription/SubscriptionTable.h"
#include "connection/ConnectionTable.h"
#include "link/LinkTable.h"
#include "bridge/BridgeTable.h"


#include "qpid_api.h"

// qpid broker options
// overridden from command line or config files
char		   *qpidBrokerUrl;
char		   *qpidBrokerConnectOptions;
char		   *qpidQmfOptions;

/*
 * If compiling within the net-snmp source code, this will trigger the feature
 * detection mechansim to ensure the agent_check_and_process() function
 * is left available even if --enable-minimialist is turned on.  If you
 * have configured net-snmp using --enable-minimialist and want to compile
 * this code externally to the Net-SNMP code base, then please add
 * --with-features="agent_check_and_process enable_stderrlog" to your
 * configure line.
 */
netsnmp_feature_require(agent_check_and_process)
    netsnmp_feature_require(enable_stderrlog)

     static int      keep_running;

     static          RETSIGTYPE stop_server(int a)
{
    keep_running = 0;
}

static void
usage(void)
{
    printf
        ("usage: qpid-snmp [-D<tokens>] [-f] [-L] [-M] [-H] [-b<broker url>]\n\t[-c<broker connection options>] [-q<qmfOptions>] [LISTENING ADDRESSES]\n"
         "\t-f      Do not fork() from the calling shell.\n"
         "\t-DTOKEN[,TOKEN,...]\n"
         "\t\tTurn on debugging output for the given TOKEN(s).\n"
         "\t\tWithout any tokens specified, it defaults to printing\n"
         "\t\tall the tokens (which is equivalent to the keyword 'ALL').\n"
         "\t\tYou might want to try ALL for extremely verbose output.\n"
         "\t\tNote: You can't put a space between the -D and the TOKENs.\n"
         "\t-H\tDisplay a list of configuration file directives\n"
         "\t\tunderstood by the agent and then exit.\n"
         "\t-M\tRun as a normal SNMP Agent instead of an AgentX sub-agent.\n"
         "\t-x ADDRESS\tconnect to master agent at ADDRESS (default /var/agentx/master).\n"
         "\t-L\tDo not open a log file; print all messages to stderr.\n"
         "\t-b\tThe URL of the broker to monitor. Defaults to localhost:5672.\n"
         "\t-c\tAdditional options to pass to the broker when connecting."
         "\t-q\tOptions to use when connecting through qmf. Defaults to {strict-security:False}");
    exit(0);
}

// called by init_snmp("qpid010")
// called
void
set_broker_config_params(const char *name, char * value)
{
	if (strcmp(name, "broker") == 0) {
		qpidBrokerUrl = malloc(strlen(value) + 1);
		strcpy(qpidBrokerUrl, value);
        DEBUGMSGTL(("read broker value from config file: %s\n", qpidBrokerUrl));
	} else if (strcmp(name, "connect") == 0) {
		qpidBrokerConnectOptions = malloc(strlen(value) + 1);
		strcpy(qpidBrokerConnectOptions, value);
		DEBUGMSGTL(("read connect value from config file: %s\n", qpidBrokerConnectOptions));
	} else if (strcmp(name, "qmf") == 0) {
		qpidQmfOptions = malloc(strlen(value) + 1);
		strcpy(qpidQmfOptions, value);
		DEBUGMSGTL(("read qmf value from config file: %s\n", qpidQmfOptions));
	}
}

int
main(int argc, char **argv)
{
    int             agentx_subagent = 0;        /* change this if you don't want to be a SNMP master agent */
    /*
     * Defs for arg-handling code: handles setting of policy-related variables 
     */
    int             ch;
    extern char    *optarg;
    int             dont_fork = 0, use_syslog = 0;
    char           *agentx_socket = NULL;

    char		   *qpidBrokerUrl_default = "localhost:5672";
    char		   *qpidBrokerConnectOptions_default = "";
    char		   *qpidQmfOptions_default = "{strict-security:False}";

    char		   *qpidBrokerUrl_cmdl = NULL;
    char		   *qpidBrokerConnectOptions_cmdl = NULL;
    char		   *qpidQmfOptions_cmdl = NULL;

    while ((ch = getopt(argc, argv, "D:b:c:q:fHLMx:")) != EOF)
        switch (ch) {
        case 'D':
            debug_register_tokens(optarg);
            snmp_set_do_debugging(1);
            break;
        case 'b':
        	qpidBrokerUrl_cmdl = optarg;
        	break;
        case 'c':
        	qpidBrokerConnectOptions_cmdl = optarg;
        	break;
        case 'q':
        	qpidQmfOptions_cmdl = optarg;
        	break;
        case 'f':
            dont_fork = 1;
            break;
        case 'H':
            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
                                   NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
            init_agent("qpid010");     /* register our .conf handlers */
            init_snmp("qpid010");
            fprintf(stderr, "Configuration directives understood:\n");
            read_config_print_usage("  ");
            exit(0);
        case 'M':
            agentx_subagent = 0;
            break;
        case 'L':
            use_syslog = 0;     /* use stderr */
            break;
        case 'x':
            agentx_socket = optarg;
            break;
        default:
            fprintf(stderr, "unknown option %c\n", ch);
            usage();
            break;
        }

    if (optind < argc) {
        int             i;
        /*
         * There are optional transport addresses on the command line.  
         */
        DEBUGMSGTL(("snmpd/main", "optind %d, argc %d\n", optind, argc));
        for (i = optind; i < argc; i++) {
            char           *c, *astring;
            if ((c = netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,
                                           NETSNMP_DS_AGENT_PORTS))) {
                astring = malloc(strlen(c) + 2 + strlen(argv[i]));
                if (astring == NULL) {
                    fprintf(stderr, "malloc failure processing argv[%d]\n",
                            i);
                    exit(1);
                }
                sprintf(astring, "%s,%s", c, argv[i]);
                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                      NETSNMP_DS_AGENT_PORTS, astring);
                SNMP_FREE(astring);
            } else {
                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                      NETSNMP_DS_AGENT_PORTS, argv[i]);
            }
        }
        DEBUGMSGTL(("snmpd/main", "port spec: %s\n",
                    netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,
                                          NETSNMP_DS_AGENT_PORTS)));
    }

    /*
     * we're an agentx subagent? 
     */
    if (agentx_subagent) {
        /*
         * make us a agentx client. 
         */
        netsnmp_enable_subagent();
        if (NULL != agentx_socket)
            netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                  NETSNMP_DS_AGENT_X_SOCKET,
                                  agentx_socket);
    }

    snmp_disable_log();
    if (use_syslog)
        snmp_enable_calllog();
    else
        snmp_enable_stderrlog();

    /*
     * daemonize 
     */
    if (!dont_fork) {
        int             rc = netsnmp_daemonize(1, !use_syslog);
        if (rc) {
        	exit(-1);
        }
    }

    /*
     * initialize tcp/ip if necessary 
     */
    SOCK_STARTUP;


    /*
     * initialize the agent library
     */
    init_agent("qpid010");

    /*
     * init tables mib code
     */
    init_QueueTable();
    init_ExchangeTable();
    init_VhostTable();
    init_BindingTable();
    init_SessionTable();
    init_SubscriptionTable();
    init_ConnectionTable();
    init_LinkTable();
    init_BridgeTable();
    init_System();
    init_Acl();
    init_HaBroker();
    init_Agent();
    init_Broker();
    init_Cluster();
    init_Memory();
    init_ManagementSetupState();

    register_config_handler("qpid010", "broker", set_broker_config_params, NULL, "URL");
    register_config_handler("qpid010", "connect", set_broker_config_params, NULL, NULL);
    register_config_handler("qpid010", "qmf", set_broker_config_params, NULL, NULL);
    /*
     * read qpid010.conf files.
	 * This has the side-effect of calling set_broker_config_params() if
	 * one of our config entries is encountered.
     */
    init_snmp("qpid010");

    /*
     * Connect to the broker
     */

    // command line | config file | default
    if (qpidBrokerUrl_cmdl) {
    	if (qpidBrokerUrl)
    		free(qpidBrokerUrl);
    	qpidBrokerUrl = qpidBrokerUrl_cmdl;
    }
    if (qpidBrokerConnectOptions_cmdl) {
    	if (qpidBrokerConnectOptions)
    		free(qpidBrokerConnectOptions);
    	qpidBrokerConnectOptions = qpidBrokerConnectOptions_cmdl;
    }
    if (qpidQmfOptions_cmdl) {
    	if (qpidQmfOptions)
    		free(qpidQmfOptions);
    	qpidQmfOptions = qpidQmfOptions_cmdl;
    }
    // the init_snmp() call above will load any config entries into the global variables
    if (!qpidBrokerUrl)
    	qpidBrokerUrl = qpidBrokerUrl_default;
    if (!qpidBrokerConnectOptions)
    	qpidBrokerConnectOptions = qpidBrokerConnectOptions_default;
    if (!qpidQmfOptions)
    	qpidQmfOptions = qpidQmfOptions_default;

    if (!init_qmf(qpidBrokerUrl, qpidBrokerConnectOptions, qpidQmfOptions)) {
        DEBUGMSGTL(("qpid-snmp/main", "failed to connect to broker %s\n", qpidBrokerUrl));
        printf("qpid-snmp/main: failed to connect to broker %s\n", qpidBrokerUrl);
        exit(-1);
    }

    /*
     * If we're going to be a snmp master agent, initial the ports 
     */
    if (!agentx_subagent)
        init_master_agent();    /* open the port to listen on (defaults to udp:161) */

    /*
     * In case we recevie a request to stop (kill -TERM or kill -INT) 
     */
    keep_running = 1;
    signal(SIGTERM, stop_server);
    signal(SIGINT, stop_server);

    /*
     * main loop...
     */
    printf("qpid agent listening...\n");
    while (keep_running) {
        /*
         * if you use select(), see snmp_select_info() in snmp_api(3) 
         */
        /*
         * --- OR ---  
         */
        agent_check_and_process(1);     /* 0 == don't block */
    }

    /*
     * at shutdown time 
     */
    close_qmf();
    snmp_shutdown("qpid010");
    SOCK_CLEANUP;
    exit(0);
}
