/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "rhm010ConnectionTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement rhm010ConnectionTable get routines.
 * TODO:240:M: Implement rhm010ConnectionTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table rhm010ConnectionTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * MRG-MESSAGING-MIB::rhm010ConnectionTable is subid 1 of rhm010Connections.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement rhm010ConnectionTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param rhm010ConnectionInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
rhm010ConnectionTable_indexes_set_tbl_idx(rhm010ConnectionTable_mib_index *
                                          tbl_idx,
                                          u_long
                                          rhm010ConnectionInternalIndex_val)
{
    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionTable_indexes_set_tbl_idx", "called\n"));

    /*
     * rhm010ConnectionInternalIndex(21)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->rhm010ConnectionInternalIndex =
        rhm010ConnectionInternalIndex_val;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
rhm010ConnectionTable_indexes_set(rhm010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long rhm010ConnectionInternalIndex_val)
{
    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        rhm010ConnectionTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                  rhm010ConnectionInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != rhm010ConnectionTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* rhm010ConnectionTable_indexes_set */


/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionVhostRef
 * rhm010ConnectionVhostRef is subid 1 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.1
 * Description:
Connection vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010ConnectionVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010ConnectionVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010ConnectionVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010ConnectionVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010ConnectionVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010ConnectionVhostRef_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                             char **rhm010ConnectionVhostRef_val_ptr_ptr,
                             size_t
                             *rhm010ConnectionVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010ConnectionVhostRef_val_ptr_ptr)
                   && (NULL != *rhm010ConnectionVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010ConnectionVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionVhostRef_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionVhostRef data.
     * copy (* rhm010ConnectionVhostRef_val_ptr_ptr ) data and (* rhm010ConnectionVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010ConnectionVhostRef data
     */
    if ((NULL == (*rhm010ConnectionVhostRef_val_ptr_ptr)) ||
        ((*rhm010ConnectionVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010ConnectionVhostRef_len *
          sizeof(rowreq_ctx->data.rhm010ConnectionVhostRef[0])))) {
        /*
         * allocate space for rhm010ConnectionVhostRef data
         */
        (*rhm010ConnectionVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010ConnectionVhostRef_len *
                   sizeof(rowreq_ctx->data.rhm010ConnectionVhostRef[0]));
        if (NULL == (*rhm010ConnectionVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010ConnectionVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010ConnectionVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010ConnectionVhostRef_len *
        sizeof(rowreq_ctx->data.rhm010ConnectionVhostRef[0]);
    memcpy((*rhm010ConnectionVhostRef_val_ptr_ptr),
           rowreq_ctx->data.rhm010ConnectionVhostRef,
           rowreq_ctx->data.rhm010ConnectionVhostRef_len *
           sizeof(rowreq_ctx->data.rhm010ConnectionVhostRef[0]));

    return MFD_SUCCESS;
}                               /* rhm010ConnectionVhostRef_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionAddress
 * rhm010ConnectionAddress is subid 2 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.2
 * Description:
Connection address
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010ConnectionAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010ConnectionAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010ConnectionAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010ConnectionAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010ConnectionAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010ConnectionAddress_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            char **rhm010ConnectionAddress_val_ptr_ptr,
                            size_t
                            *rhm010ConnectionAddress_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010ConnectionAddress_val_ptr_ptr)
                   && (NULL != *rhm010ConnectionAddress_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010ConnectionAddress_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionAddress_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionAddress data.
     * copy (* rhm010ConnectionAddress_val_ptr_ptr ) data and (* rhm010ConnectionAddress_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010ConnectionAddress data
     */
    if ((NULL == (*rhm010ConnectionAddress_val_ptr_ptr)) ||
        ((*rhm010ConnectionAddress_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010ConnectionAddress_len *
          sizeof(rowreq_ctx->data.rhm010ConnectionAddress[0])))) {
        /*
         * allocate space for rhm010ConnectionAddress data
         */
        (*rhm010ConnectionAddress_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010ConnectionAddress_len *
                   sizeof(rowreq_ctx->data.rhm010ConnectionAddress[0]));
        if (NULL == (*rhm010ConnectionAddress_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010ConnectionAddress)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010ConnectionAddress_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010ConnectionAddress_len *
        sizeof(rowreq_ctx->data.rhm010ConnectionAddress[0]);
    memcpy((*rhm010ConnectionAddress_val_ptr_ptr),
           rowreq_ctx->data.rhm010ConnectionAddress,
           rowreq_ctx->data.rhm010ConnectionAddress_len *
           sizeof(rowreq_ctx->data.rhm010ConnectionAddress[0]));

    return MFD_SUCCESS;
}                               /* rhm010ConnectionAddress_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionIncoming
 * rhm010ConnectionIncoming is subid 3 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.3
 * Description:
Connection incoming
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionIncoming data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionIncoming_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionIncoming_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                             u_long * rhm010ConnectionIncoming_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionIncoming_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionIncoming_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionIncoming data.
     * copy (* rhm010ConnectionIncoming_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionIncoming_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionIncoming;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionIncoming_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionSystemConnection
 * rhm010ConnectionSystemConnection is subid 4 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.4
 * Description:
Infrastructure/ Inter-system connection (Cluster, Federation, ...)
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionSystemConnection data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionSystemConnection_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionSystemConnection_get(rhm010ConnectionTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     rhm010ConnectionSystemConnection_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionSystemConnection_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionSystemConnection_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionSystemConnection data.
     * copy (* rhm010ConnectionSystemConnection_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionSystemConnection_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionSystemConnection;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionSystemConnection_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionUserProxyAuth
 * rhm010ConnectionUserProxyAuth is subid 5 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.5
 * Description:
Authorization to proxy for users not on broker
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionUserProxyAuth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionUserProxyAuth_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionUserProxyAuth_get(rhm010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long *
                                  rhm010ConnectionUserProxyAuth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionUserProxyAuth_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionUserProxyAuth_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionUserProxyAuth data.
     * copy (* rhm010ConnectionUserProxyAuth_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionUserProxyAuth_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionUserProxyAuth;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionUserProxyAuth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionFederationLink
 * rhm010ConnectionFederationLink is subid 6 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.6
 * Description:
Is this a federation link
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionFederationLink data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionFederationLink_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionFederationLink_get(rhm010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   rhm010ConnectionFederationLink_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionFederationLink_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionFederationLink_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionFederationLink data.
     * copy (* rhm010ConnectionFederationLink_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionFederationLink_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionFederationLink;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionFederationLink_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionAuthIdentity
 * rhm010ConnectionAuthIdentity is subid 7 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.7
 * Description:
authId of connection if authentication enabled
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010ConnectionAuthIdentity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionAuthIdentity_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010ConnectionAuthIdentity_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010ConnectionAuthIdentity.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010ConnectionAuthIdentity_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010ConnectionAuthIdentity_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010ConnectionAuthIdentity_get(rhm010ConnectionTable_rowreq_ctx *
                                 rowreq_ctx,
                                 char
                                 **rhm010ConnectionAuthIdentity_val_ptr_ptr,
                                 size_t
                                 *rhm010ConnectionAuthIdentity_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010ConnectionAuthIdentity_val_ptr_ptr)
                   && (NULL != *rhm010ConnectionAuthIdentity_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010ConnectionAuthIdentity_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionAuthIdentity_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionAuthIdentity data.
     * copy (* rhm010ConnectionAuthIdentity_val_ptr_ptr ) data and (* rhm010ConnectionAuthIdentity_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010ConnectionAuthIdentity data
     */
    if ((NULL == (*rhm010ConnectionAuthIdentity_val_ptr_ptr)) ||
        ((*rhm010ConnectionAuthIdentity_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010ConnectionAuthIdentity_len *
          sizeof(rowreq_ctx->data.rhm010ConnectionAuthIdentity[0])))) {
        /*
         * allocate space for rhm010ConnectionAuthIdentity data
         */
        (*rhm010ConnectionAuthIdentity_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010ConnectionAuthIdentity_len *
                   sizeof(rowreq_ctx->data.
                          rhm010ConnectionAuthIdentity[0]));
        if (NULL == (*rhm010ConnectionAuthIdentity_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010ConnectionAuthIdentity)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010ConnectionAuthIdentity_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010ConnectionAuthIdentity_len *
        sizeof(rowreq_ctx->data.rhm010ConnectionAuthIdentity[0]);
    memcpy((*rhm010ConnectionAuthIdentity_val_ptr_ptr),
           rowreq_ctx->data.rhm010ConnectionAuthIdentity,
           rowreq_ctx->data.rhm010ConnectionAuthIdentity_len *
           sizeof(rowreq_ctx->data.rhm010ConnectionAuthIdentity[0]));

    return MFD_SUCCESS;
}                               /* rhm010ConnectionAuthIdentity_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionRemoteProcessName
 * rhm010ConnectionRemoteProcessName is subid 8 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.8
 * Description:
Name of executable running as remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Lstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the rhm010ConnectionRemoteProcessName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionRemoteProcessName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010ConnectionRemoteProcessName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010ConnectionRemoteProcessName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010ConnectionRemoteProcessName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010ConnectionRemoteProcessName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010ConnectionRemoteProcessName_get(rhm010ConnectionTable_rowreq_ctx *
                                      rowreq_ctx,
                                      char
                                      **rhm010ConnectionRemoteProcessName_val_ptr_ptr,
                                      size_t
                                      *rhm010ConnectionRemoteProcessName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010ConnectionRemoteProcessName_val_ptr_ptr)
                   && (NULL !=
                       *rhm010ConnectionRemoteProcessName_val_ptr_ptr));
    netsnmp_assert(NULL !=
                   rhm010ConnectionRemoteProcessName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionRemoteProcessName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionRemoteProcessName data.
     * copy (* rhm010ConnectionRemoteProcessName_val_ptr_ptr ) data and (* rhm010ConnectionRemoteProcessName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010ConnectionRemoteProcessName data
     */
    if ((NULL == (*rhm010ConnectionRemoteProcessName_val_ptr_ptr)) ||
        ((*rhm010ConnectionRemoteProcessName_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010ConnectionRemoteProcessName_len *
          sizeof(rowreq_ctx->data.
                 rhm010ConnectionRemoteProcessName[0])))) {
        /*
         * allocate space for rhm010ConnectionRemoteProcessName data
         */
        (*rhm010ConnectionRemoteProcessName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010ConnectionRemoteProcessName_len *
                   sizeof(rowreq_ctx->data.
                          rhm010ConnectionRemoteProcessName[0]));
        if (NULL == (*rhm010ConnectionRemoteProcessName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010ConnectionRemoteProcessName)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010ConnectionRemoteProcessName_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010ConnectionRemoteProcessName_len *
        sizeof(rowreq_ctx->data.rhm010ConnectionRemoteProcessName[0]);
    memcpy((*rhm010ConnectionRemoteProcessName_val_ptr_ptr),
           rowreq_ctx->data.rhm010ConnectionRemoteProcessName,
           rowreq_ctx->data.rhm010ConnectionRemoteProcessName_len *
           sizeof(rowreq_ctx->data.rhm010ConnectionRemoteProcessName[0]));

    return MFD_SUCCESS;
}                               /* rhm010ConnectionRemoteProcessName_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionRemotePid
 * rhm010ConnectionRemotePid is subid 9 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.9
 * Description:
Process ID of remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionRemotePid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionRemotePid_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionRemotePid_get(rhm010ConnectionTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long * rhm010ConnectionRemotePid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionRemotePid_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionRemotePid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionRemotePid data.
     * copy (* rhm010ConnectionRemotePid_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionRemotePid_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionRemotePid;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionRemotePid_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionRemoteParentPid
 * rhm010ConnectionRemoteParentPid is subid 10 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.10
 * Description:
Parent Process ID of remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionRemoteParentPid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionRemoteParentPid_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionRemoteParentPid_get(rhm010ConnectionTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long *
                                    rhm010ConnectionRemoteParentPid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionRemoteParentPid_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionRemoteParentPid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionRemoteParentPid data.
     * copy (* rhm010ConnectionRemoteParentPid_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionRemoteParentPid_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionRemoteParentPid;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionRemoteParentPid_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionShadow
 * rhm010ConnectionShadow is subid 11 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.11
 * Description:
True for shadow connections
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionShadow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionShadow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionShadow_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                           u_long * rhm010ConnectionShadow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionShadow_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionShadow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionShadow data.
     * copy (* rhm010ConnectionShadow_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionShadow_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionShadow;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionShadow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionSaslMechanism
 * rhm010ConnectionSaslMechanism is subid 12 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.12
 * Description:
SASL mechanism
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010ConnectionSaslMechanism data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionSaslMechanism_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010ConnectionSaslMechanism_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010ConnectionSaslMechanism.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010ConnectionSaslMechanism_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010ConnectionSaslMechanism_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010ConnectionSaslMechanism_get(rhm010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  char
                                  **rhm010ConnectionSaslMechanism_val_ptr_ptr,
                                  size_t
                                  *rhm010ConnectionSaslMechanism_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010ConnectionSaslMechanism_val_ptr_ptr)
                   && (NULL !=
                       *rhm010ConnectionSaslMechanism_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010ConnectionSaslMechanism_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionSaslMechanism_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionSaslMechanism data.
     * copy (* rhm010ConnectionSaslMechanism_val_ptr_ptr ) data and (* rhm010ConnectionSaslMechanism_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010ConnectionSaslMechanism data
     */
    if ((NULL == (*rhm010ConnectionSaslMechanism_val_ptr_ptr)) ||
        ((*rhm010ConnectionSaslMechanism_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010ConnectionSaslMechanism_len *
          sizeof(rowreq_ctx->data.rhm010ConnectionSaslMechanism[0])))) {
        /*
         * allocate space for rhm010ConnectionSaslMechanism data
         */
        (*rhm010ConnectionSaslMechanism_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010ConnectionSaslMechanism_len *
                   sizeof(rowreq_ctx->data.
                          rhm010ConnectionSaslMechanism[0]));
        if (NULL == (*rhm010ConnectionSaslMechanism_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010ConnectionSaslMechanism)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010ConnectionSaslMechanism_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010ConnectionSaslMechanism_len *
        sizeof(rowreq_ctx->data.rhm010ConnectionSaslMechanism[0]);
    memcpy((*rhm010ConnectionSaslMechanism_val_ptr_ptr),
           rowreq_ctx->data.rhm010ConnectionSaslMechanism,
           rowreq_ctx->data.rhm010ConnectionSaslMechanism_len *
           sizeof(rowreq_ctx->data.rhm010ConnectionSaslMechanism[0]));

    return MFD_SUCCESS;
}                               /* rhm010ConnectionSaslMechanism_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionSaslSsf
 * rhm010ConnectionSaslSsf is subid 13 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.13
 * Description:
SASL security strength factor
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Uint16 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010ConnectionSaslSsf data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionSaslSsf_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionSaslSsf_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            long *rhm010ConnectionSaslSsf_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionSaslSsf_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionSaslSsf_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionSaslSsf data.
     * copy (* rhm010ConnectionSaslSsf_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionSaslSsf_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionSaslSsf;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionSaslSsf_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionClosing
 * rhm010ConnectionClosing is subid 14 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.14
 * Description:
This client is closing by management request
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010ConnectionClosing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionClosing_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionClosing_get(rhm010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            u_long * rhm010ConnectionClosing_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionClosing_val_ptr);


    DEBUGMSGTL(("verbose:rhm010ConnectionTable:rhm010ConnectionClosing_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010ConnectionClosing data.
     * copy (* rhm010ConnectionClosing_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010ConnectionClosing_val_ptr) =
        rowreq_ctx->data.rhm010ConnectionClosing;

    return MFD_SUCCESS;
}                               /* rhm010ConnectionClosing_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionFramesFromClient
 * rhm010ConnectionFramesFromClient is subid 15 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.15
 * Description:
Connection framesFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionFramesFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionFramesFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionFramesFromClient_get(rhm010ConnectionTable_rowreq_ctx *
                                     rowreq_ctx,
                                     U64 *
                                     rhm010ConnectionFramesFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionFramesFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionFramesFromClient data.
     * get (* rhm010ConnectionFramesFromClient_val_ptr ).low and (* rhm010ConnectionFramesFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionFramesFromClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionFramesFromClient.high;
    (*rhm010ConnectionFramesFromClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionFramesFromClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionFramesFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionFramesToClient
 * rhm010ConnectionFramesToClient is subid 16 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.16
 * Description:
Connection framesToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionFramesToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionFramesToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionFramesToClient_get(rhm010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   rhm010ConnectionFramesToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionFramesToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionFramesToClient data.
     * get (* rhm010ConnectionFramesToClient_val_ptr ).low and (* rhm010ConnectionFramesToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionFramesToClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionFramesToClient.high;
    (*rhm010ConnectionFramesToClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionFramesToClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionFramesToClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionBytesFromClient
 * rhm010ConnectionBytesFromClient is subid 17 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.17
 * Description:
Connection bytesFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionBytesFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionBytesFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionBytesFromClient_get(rhm010ConnectionTable_rowreq_ctx *
                                    rowreq_ctx,
                                    U64 *
                                    rhm010ConnectionBytesFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionBytesFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionBytesFromClient data.
     * get (* rhm010ConnectionBytesFromClient_val_ptr ).low and (* rhm010ConnectionBytesFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionBytesFromClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionBytesFromClient.high;
    (*rhm010ConnectionBytesFromClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionBytesFromClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionBytesFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionBytesToClient
 * rhm010ConnectionBytesToClient is subid 18 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.18
 * Description:
Connection bytesToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionBytesToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionBytesToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionBytesToClient_get(rhm010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  U64 *
                                  rhm010ConnectionBytesToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionBytesToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionBytesToClient data.
     * get (* rhm010ConnectionBytesToClient_val_ptr ).low and (* rhm010ConnectionBytesToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionBytesToClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionBytesToClient.high;
    (*rhm010ConnectionBytesToClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionBytesToClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionBytesToClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionMsgsFromClient
 * rhm010ConnectionMsgsFromClient is subid 19 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.19
 * Description:
Connection msgsFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionMsgsFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionMsgsFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionMsgsFromClient_get(rhm010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   rhm010ConnectionMsgsFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionMsgsFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionMsgsFromClient data.
     * get (* rhm010ConnectionMsgsFromClient_val_ptr ).low and (* rhm010ConnectionMsgsFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionMsgsFromClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionMsgsFromClient.high;
    (*rhm010ConnectionMsgsFromClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionMsgsFromClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionMsgsFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010ConnectionEntry.rhm010ConnectionMsgsToClient
 * rhm010ConnectionMsgsToClient is subid 20 of rhm010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.10.1.1.20
 * Description:
Connection msgsToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010ConnectionMsgsToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010ConnectionMsgsToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010ConnectionMsgsToClient_get(rhm010ConnectionTable_rowreq_ctx *
                                 rowreq_ctx,
                                 U64 *
                                 rhm010ConnectionMsgsToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010ConnectionMsgsToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010ConnectionMsgsToClient data.
     * get (* rhm010ConnectionMsgsToClient_val_ptr ).low and (* rhm010ConnectionMsgsToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010ConnectionMsgsToClient_val_ptr).high =
        rowreq_ctx->data.rhm010ConnectionMsgsToClient.high;
    (*rhm010ConnectionMsgsToClient_val_ptr).low =
        rowreq_ctx->data.rhm010ConnectionMsgsToClient.low;


    return MFD_SUCCESS;
}                               /* rhm010ConnectionMsgsToClient_get */



/** @} */
