/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ConnectionTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement qpid010ConnectionTable get routines.
 * TODO:240:M: Implement qpid010ConnectionTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table qpid010ConnectionTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * MRG-MESSAGING-MIB::qpid010ConnectionTable is subid 1 of qpid010Connections.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement qpid010ConnectionTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param qpid010ConnectionInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
qpid010ConnectionTable_indexes_set_tbl_idx(qpid010ConnectionTable_mib_index *
                                          tbl_idx,
                                          u_long
                                          qpid010ConnectionInternalIndex_val)
{
    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionTable_indexes_set_tbl_idx", "called\n"));

    /*
     * qpid010ConnectionInternalIndex(21)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->qpid010ConnectionInternalIndex =
        qpid010ConnectionInternalIndex_val;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
qpid010ConnectionTable_indexes_set(qpid010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long qpid010ConnectionInternalIndex_val)
{
    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        qpid010ConnectionTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                  qpid010ConnectionInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != qpid010ConnectionTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* qpid010ConnectionTable_indexes_set */


/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionVhostRef
 * qpid010ConnectionVhostRef is subid 1 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.1
 * Description:
Connection vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010ConnectionVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010ConnectionVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010ConnectionVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010ConnectionVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010ConnectionVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010ConnectionVhostRef_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                             char **qpid010ConnectionVhostRef_val_ptr_ptr,
                             size_t
                             *qpid010ConnectionVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010ConnectionVhostRef_val_ptr_ptr)
                   && (NULL != *qpid010ConnectionVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010ConnectionVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionVhostRef_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionVhostRef data.
     * copy (* qpid010ConnectionVhostRef_val_ptr_ptr ) data and (* qpid010ConnectionVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010ConnectionVhostRef data
     */
    if ((NULL == (*qpid010ConnectionVhostRef_val_ptr_ptr)) ||
        ((*qpid010ConnectionVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010ConnectionVhostRef_len *
          sizeof(rowreq_ctx->data.qpid010ConnectionVhostRef[0])))) {
        /*
         * allocate space for qpid010ConnectionVhostRef data
         */
        (*qpid010ConnectionVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010ConnectionVhostRef_len *
                   sizeof(rowreq_ctx->data.qpid010ConnectionVhostRef[0]));
        if (NULL == (*qpid010ConnectionVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010ConnectionVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010ConnectionVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010ConnectionVhostRef_len *
        sizeof(rowreq_ctx->data.qpid010ConnectionVhostRef[0]);
    memcpy((*qpid010ConnectionVhostRef_val_ptr_ptr),
           rowreq_ctx->data.qpid010ConnectionVhostRef,
           rowreq_ctx->data.qpid010ConnectionVhostRef_len *
           sizeof(rowreq_ctx->data.qpid010ConnectionVhostRef[0]));

    return MFD_SUCCESS;
}                               /* qpid010ConnectionVhostRef_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionAddress
 * qpid010ConnectionAddress is subid 2 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.2
 * Description:
Connection address
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010ConnectionAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010ConnectionAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010ConnectionAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010ConnectionAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010ConnectionAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010ConnectionAddress_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            char **qpid010ConnectionAddress_val_ptr_ptr,
                            size_t
                            *qpid010ConnectionAddress_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010ConnectionAddress_val_ptr_ptr)
                   && (NULL != *qpid010ConnectionAddress_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010ConnectionAddress_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionAddress_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionAddress data.
     * copy (* qpid010ConnectionAddress_val_ptr_ptr ) data and (* qpid010ConnectionAddress_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010ConnectionAddress data
     */
    if ((NULL == (*qpid010ConnectionAddress_val_ptr_ptr)) ||
        ((*qpid010ConnectionAddress_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010ConnectionAddress_len *
          sizeof(rowreq_ctx->data.qpid010ConnectionAddress[0])))) {
        /*
         * allocate space for qpid010ConnectionAddress data
         */
        (*qpid010ConnectionAddress_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010ConnectionAddress_len *
                   sizeof(rowreq_ctx->data.qpid010ConnectionAddress[0]));
        if (NULL == (*qpid010ConnectionAddress_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010ConnectionAddress)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010ConnectionAddress_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010ConnectionAddress_len *
        sizeof(rowreq_ctx->data.qpid010ConnectionAddress[0]);
    memcpy((*qpid010ConnectionAddress_val_ptr_ptr),
           rowreq_ctx->data.qpid010ConnectionAddress,
           rowreq_ctx->data.qpid010ConnectionAddress_len *
           sizeof(rowreq_ctx->data.qpid010ConnectionAddress[0]));

    return MFD_SUCCESS;
}                               /* qpid010ConnectionAddress_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionIncoming
 * qpid010ConnectionIncoming is subid 3 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.3
 * Description:
Connection incoming
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionIncoming data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionIncoming_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionIncoming_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                             u_long * qpid010ConnectionIncoming_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionIncoming_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionIncoming_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionIncoming data.
     * copy (* qpid010ConnectionIncoming_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionIncoming_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionIncoming;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionIncoming_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionSystemConnection
 * qpid010ConnectionSystemConnection is subid 4 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.4
 * Description:
Infrastructure/ Inter-system connection (Cluster, Federation, ...)
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionSystemConnection data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionSystemConnection_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionSystemConnection_get(qpid010ConnectionTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     qpid010ConnectionSystemConnection_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionSystemConnection_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionSystemConnection_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionSystemConnection data.
     * copy (* qpid010ConnectionSystemConnection_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionSystemConnection_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionSystemConnection;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionSystemConnection_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionUserProxyAuth
 * qpid010ConnectionUserProxyAuth is subid 5 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.5
 * Description:
Authorization to proxy for users not on broker
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionUserProxyAuth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionUserProxyAuth_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionUserProxyAuth_get(qpid010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long *
                                  qpid010ConnectionUserProxyAuth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionUserProxyAuth_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionUserProxyAuth_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionUserProxyAuth data.
     * copy (* qpid010ConnectionUserProxyAuth_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionUserProxyAuth_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionUserProxyAuth;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionUserProxyAuth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionFederationLink
 * qpid010ConnectionFederationLink is subid 6 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.6
 * Description:
Is this a federation link
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionFederationLink data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionFederationLink_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionFederationLink_get(qpid010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   qpid010ConnectionFederationLink_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionFederationLink_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionFederationLink_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionFederationLink data.
     * copy (* qpid010ConnectionFederationLink_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionFederationLink_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionFederationLink;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionFederationLink_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionAuthIdentity
 * qpid010ConnectionAuthIdentity is subid 7 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.7
 * Description:
authId of connection if authentication enabled
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010ConnectionAuthIdentity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionAuthIdentity_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010ConnectionAuthIdentity_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010ConnectionAuthIdentity.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010ConnectionAuthIdentity_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010ConnectionAuthIdentity_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010ConnectionAuthIdentity_get(qpid010ConnectionTable_rowreq_ctx *
                                 rowreq_ctx,
                                 char
                                 **qpid010ConnectionAuthIdentity_val_ptr_ptr,
                                 size_t
                                 *qpid010ConnectionAuthIdentity_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010ConnectionAuthIdentity_val_ptr_ptr)
                   && (NULL != *qpid010ConnectionAuthIdentity_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010ConnectionAuthIdentity_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionAuthIdentity_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionAuthIdentity data.
     * copy (* qpid010ConnectionAuthIdentity_val_ptr_ptr ) data and (* qpid010ConnectionAuthIdentity_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010ConnectionAuthIdentity data
     */
    if ((NULL == (*qpid010ConnectionAuthIdentity_val_ptr_ptr)) ||
        ((*qpid010ConnectionAuthIdentity_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010ConnectionAuthIdentity_len *
          sizeof(rowreq_ctx->data.qpid010ConnectionAuthIdentity[0])))) {
        /*
         * allocate space for qpid010ConnectionAuthIdentity data
         */
        (*qpid010ConnectionAuthIdentity_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010ConnectionAuthIdentity_len *
                   sizeof(rowreq_ctx->data.
                          qpid010ConnectionAuthIdentity[0]));
        if (NULL == (*qpid010ConnectionAuthIdentity_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010ConnectionAuthIdentity)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010ConnectionAuthIdentity_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010ConnectionAuthIdentity_len *
        sizeof(rowreq_ctx->data.qpid010ConnectionAuthIdentity[0]);
    memcpy((*qpid010ConnectionAuthIdentity_val_ptr_ptr),
           rowreq_ctx->data.qpid010ConnectionAuthIdentity,
           rowreq_ctx->data.qpid010ConnectionAuthIdentity_len *
           sizeof(rowreq_ctx->data.qpid010ConnectionAuthIdentity[0]));

    return MFD_SUCCESS;
}                               /* qpid010ConnectionAuthIdentity_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionRemoteProcessName
 * qpid010ConnectionRemoteProcessName is subid 8 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.8
 * Description:
Name of executable running as remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Lstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the qpid010ConnectionRemoteProcessName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionRemoteProcessName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010ConnectionRemoteProcessName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010ConnectionRemoteProcessName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010ConnectionRemoteProcessName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010ConnectionRemoteProcessName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010ConnectionRemoteProcessName_get(qpid010ConnectionTable_rowreq_ctx *
                                      rowreq_ctx,
                                      char
                                      **qpid010ConnectionRemoteProcessName_val_ptr_ptr,
                                      size_t
                                      *qpid010ConnectionRemoteProcessName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010ConnectionRemoteProcessName_val_ptr_ptr)
                   && (NULL !=
                       *qpid010ConnectionRemoteProcessName_val_ptr_ptr));
    netsnmp_assert(NULL !=
                   qpid010ConnectionRemoteProcessName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionRemoteProcessName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionRemoteProcessName data.
     * copy (* qpid010ConnectionRemoteProcessName_val_ptr_ptr ) data and (* qpid010ConnectionRemoteProcessName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010ConnectionRemoteProcessName data
     */
    if ((NULL == (*qpid010ConnectionRemoteProcessName_val_ptr_ptr)) ||
        ((*qpid010ConnectionRemoteProcessName_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010ConnectionRemoteProcessName_len *
          sizeof(rowreq_ctx->data.
                 qpid010ConnectionRemoteProcessName[0])))) {
        /*
         * allocate space for qpid010ConnectionRemoteProcessName data
         */
        (*qpid010ConnectionRemoteProcessName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010ConnectionRemoteProcessName_len *
                   sizeof(rowreq_ctx->data.
                          qpid010ConnectionRemoteProcessName[0]));
        if (NULL == (*qpid010ConnectionRemoteProcessName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010ConnectionRemoteProcessName)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010ConnectionRemoteProcessName_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010ConnectionRemoteProcessName_len *
        sizeof(rowreq_ctx->data.qpid010ConnectionRemoteProcessName[0]);
    memcpy((*qpid010ConnectionRemoteProcessName_val_ptr_ptr),
           rowreq_ctx->data.qpid010ConnectionRemoteProcessName,
           rowreq_ctx->data.qpid010ConnectionRemoteProcessName_len *
           sizeof(rowreq_ctx->data.qpid010ConnectionRemoteProcessName[0]));

    return MFD_SUCCESS;
}                               /* qpid010ConnectionRemoteProcessName_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionRemotePid
 * qpid010ConnectionRemotePid is subid 9 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.9
 * Description:
Process ID of remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionRemotePid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionRemotePid_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionRemotePid_get(qpid010ConnectionTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long * qpid010ConnectionRemotePid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionRemotePid_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionRemotePid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionRemotePid data.
     * copy (* qpid010ConnectionRemotePid_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionRemotePid_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionRemotePid;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionRemotePid_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionRemoteParentPid
 * qpid010ConnectionRemoteParentPid is subid 10 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.10
 * Description:
Parent Process ID of remote client
                     Additional info ( nodeType:property, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionRemoteParentPid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionRemoteParentPid_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionRemoteParentPid_get(qpid010ConnectionTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long *
                                    qpid010ConnectionRemoteParentPid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionRemoteParentPid_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionRemoteParentPid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionRemoteParentPid data.
     * copy (* qpid010ConnectionRemoteParentPid_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionRemoteParentPid_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionRemoteParentPid;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionRemoteParentPid_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionShadow
 * qpid010ConnectionShadow is subid 11 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.11
 * Description:
True for shadow connections
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionShadow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionShadow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionShadow_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                           u_long * qpid010ConnectionShadow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionShadow_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionShadow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionShadow data.
     * copy (* qpid010ConnectionShadow_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionShadow_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionShadow;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionShadow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionSaslMechanism
 * qpid010ConnectionSaslMechanism is subid 12 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.12
 * Description:
SASL mechanism
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010ConnectionSaslMechanism data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionSaslMechanism_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010ConnectionSaslMechanism_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010ConnectionSaslMechanism.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010ConnectionSaslMechanism_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010ConnectionSaslMechanism_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010ConnectionSaslMechanism_get(qpid010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  char
                                  **qpid010ConnectionSaslMechanism_val_ptr_ptr,
                                  size_t
                                  *qpid010ConnectionSaslMechanism_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010ConnectionSaslMechanism_val_ptr_ptr)
                   && (NULL !=
                       *qpid010ConnectionSaslMechanism_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010ConnectionSaslMechanism_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionSaslMechanism_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionSaslMechanism data.
     * copy (* qpid010ConnectionSaslMechanism_val_ptr_ptr ) data and (* qpid010ConnectionSaslMechanism_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010ConnectionSaslMechanism data
     */
    if ((NULL == (*qpid010ConnectionSaslMechanism_val_ptr_ptr)) ||
        ((*qpid010ConnectionSaslMechanism_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010ConnectionSaslMechanism_len *
          sizeof(rowreq_ctx->data.qpid010ConnectionSaslMechanism[0])))) {
        /*
         * allocate space for qpid010ConnectionSaslMechanism data
         */
        (*qpid010ConnectionSaslMechanism_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010ConnectionSaslMechanism_len *
                   sizeof(rowreq_ctx->data.
                          qpid010ConnectionSaslMechanism[0]));
        if (NULL == (*qpid010ConnectionSaslMechanism_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010ConnectionSaslMechanism)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010ConnectionSaslMechanism_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010ConnectionSaslMechanism_len *
        sizeof(rowreq_ctx->data.qpid010ConnectionSaslMechanism[0]);
    memcpy((*qpid010ConnectionSaslMechanism_val_ptr_ptr),
           rowreq_ctx->data.qpid010ConnectionSaslMechanism,
           rowreq_ctx->data.qpid010ConnectionSaslMechanism_len *
           sizeof(rowreq_ctx->data.qpid010ConnectionSaslMechanism[0]));

    return MFD_SUCCESS;
}                               /* qpid010ConnectionSaslMechanism_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionSaslSsf
 * qpid010ConnectionSaslSsf is subid 13 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.13
 * Description:
SASL security strength factor
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Uint16 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010ConnectionSaslSsf data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionSaslSsf_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionSaslSsf_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            long *qpid010ConnectionSaslSsf_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionSaslSsf_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionSaslSsf_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionSaslSsf data.
     * copy (* qpid010ConnectionSaslSsf_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionSaslSsf_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionSaslSsf;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionSaslSsf_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionClosing
 * qpid010ConnectionClosing is subid 14 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.14
 * Description:
This client is closing by management request
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010ConnectionClosing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionClosing_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionClosing_get(qpid010ConnectionTable_rowreq_ctx * rowreq_ctx,
                            u_long * qpid010ConnectionClosing_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionClosing_val_ptr);


    DEBUGMSGTL(("verbose:qpid010ConnectionTable:qpid010ConnectionClosing_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010ConnectionClosing data.
     * copy (* qpid010ConnectionClosing_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010ConnectionClosing_val_ptr) =
        rowreq_ctx->data.qpid010ConnectionClosing;

    return MFD_SUCCESS;
}                               /* qpid010ConnectionClosing_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionFramesFromClient
 * qpid010ConnectionFramesFromClient is subid 15 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.15
 * Description:
Connection framesFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionFramesFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionFramesFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionFramesFromClient_get(qpid010ConnectionTable_rowreq_ctx *
                                     rowreq_ctx,
                                     U64 *
                                     qpid010ConnectionFramesFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionFramesFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionFramesFromClient data.
     * get (* qpid010ConnectionFramesFromClient_val_ptr ).low and (* qpid010ConnectionFramesFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionFramesFromClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionFramesFromClient.high;
    (*qpid010ConnectionFramesFromClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionFramesFromClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionFramesFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionFramesToClient
 * qpid010ConnectionFramesToClient is subid 16 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.16
 * Description:
Connection framesToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionFramesToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionFramesToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionFramesToClient_get(qpid010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   qpid010ConnectionFramesToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionFramesToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionFramesToClient data.
     * get (* qpid010ConnectionFramesToClient_val_ptr ).low and (* qpid010ConnectionFramesToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionFramesToClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionFramesToClient.high;
    (*qpid010ConnectionFramesToClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionFramesToClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionFramesToClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionBytesFromClient
 * qpid010ConnectionBytesFromClient is subid 17 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.17
 * Description:
Connection bytesFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionBytesFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionBytesFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionBytesFromClient_get(qpid010ConnectionTable_rowreq_ctx *
                                    rowreq_ctx,
                                    U64 *
                                    qpid010ConnectionBytesFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionBytesFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionBytesFromClient data.
     * get (* qpid010ConnectionBytesFromClient_val_ptr ).low and (* qpid010ConnectionBytesFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionBytesFromClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionBytesFromClient.high;
    (*qpid010ConnectionBytesFromClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionBytesFromClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionBytesFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionBytesToClient
 * qpid010ConnectionBytesToClient is subid 18 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.18
 * Description:
Connection bytesToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionBytesToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionBytesToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionBytesToClient_get(qpid010ConnectionTable_rowreq_ctx *
                                  rowreq_ctx,
                                  U64 *
                                  qpid010ConnectionBytesToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionBytesToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionBytesToClient data.
     * get (* qpid010ConnectionBytesToClient_val_ptr ).low and (* qpid010ConnectionBytesToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionBytesToClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionBytesToClient.high;
    (*qpid010ConnectionBytesToClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionBytesToClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionBytesToClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionMsgsFromClient
 * qpid010ConnectionMsgsFromClient is subid 19 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.19
 * Description:
Connection msgsFromClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionMsgsFromClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionMsgsFromClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionMsgsFromClient_get(qpid010ConnectionTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   qpid010ConnectionMsgsFromClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionMsgsFromClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionMsgsFromClient data.
     * get (* qpid010ConnectionMsgsFromClient_val_ptr ).low and (* qpid010ConnectionMsgsFromClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionMsgsFromClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionMsgsFromClient.high;
    (*qpid010ConnectionMsgsFromClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionMsgsFromClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionMsgsFromClient_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010ConnectionEntry.qpid010ConnectionMsgsToClient
 * qpid010ConnectionMsgsToClient is subid 20 of qpid010ConnectionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.10.1.1.20
 * Description:
Connection msgsToClient
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010ConnectionMsgsToClient data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010ConnectionMsgsToClient_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010ConnectionMsgsToClient_get(qpid010ConnectionTable_rowreq_ctx *
                                 rowreq_ctx,
                                 U64 *
                                 qpid010ConnectionMsgsToClient_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010ConnectionMsgsToClient_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010ConnectionMsgsToClient data.
     * get (* qpid010ConnectionMsgsToClient_val_ptr ).low and (* qpid010ConnectionMsgsToClient_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010ConnectionMsgsToClient_val_ptr).high =
        rowreq_ctx->data.qpid010ConnectionMsgsToClient.high;
    (*qpid010ConnectionMsgsToClient_val_ptr).low =
        rowreq_ctx->data.qpid010ConnectionMsgsToClient.low;


    return MFD_SUCCESS;
}                               /* qpid010ConnectionMsgsToClient_get */



/** @} */
