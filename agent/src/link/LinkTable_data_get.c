/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "LinkTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement brokerLinkTable get routines.
 * TODO:240:M: Implement brokerLinkTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table brokerLinkTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * QPID-MESSAGING-MIB::brokerLinkTable is subid 1 of brokerLinks.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement brokerLinkTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param brokerLinkInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
brokerLinkTable_indexes_set_tbl_idx(brokerLinkTable_mib_index * tbl_idx,
                                     u_long brokerLinkInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkTable_indexes_set_tbl_idx", "called\n"));

    /*
     * brokerLinkInternalIndex(10)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->brokerLinkInternalIndex = brokerLinkInternalIndex_val;


    return MFD_SUCCESS;
}                               /* brokerLinkTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
brokerLinkTable_indexes_set(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                             u_long brokerLinkInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        brokerLinkTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                             brokerLinkInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != brokerLinkTable_index_to_oid(&rowreq_ctx->oid_idx,
                                           &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* brokerLinkTable_indexes_set */


/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkVhostRef
 * brokerLinkVhostRef is subid 1 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.1
 * Description:
Link vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkVhostRef_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                        char **brokerLinkVhostRef_val_ptr_ptr,
                        size_t *brokerLinkVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkVhostRef_val_ptr_ptr)
                   && (NULL != *brokerLinkVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkVhostRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkVhostRef data.
     * copy (* brokerLinkVhostRef_val_ptr_ptr ) data and (* brokerLinkVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkVhostRef data
     */
    if ((NULL == (*brokerLinkVhostRef_val_ptr_ptr)) ||
        ((*brokerLinkVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkVhostRef_len *
          sizeof(rowreq_ctx->data.brokerLinkVhostRef[0])))) {
        /*
         * allocate space for brokerLinkVhostRef data
         */
        (*brokerLinkVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkVhostRef_len *
                   sizeof(rowreq_ctx->data.brokerLinkVhostRef[0]));
        if (NULL == (*brokerLinkVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkVhostRef_len *
        sizeof(rowreq_ctx->data.brokerLinkVhostRef[0]);
    memcpy((*brokerLinkVhostRef_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkVhostRef,
           rowreq_ctx->data.brokerLinkVhostRef_len *
           sizeof(rowreq_ctx->data.brokerLinkVhostRef[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkVhostRef_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkName
 * brokerLinkName is subid 2 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.2
 * Description:
Link name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkName_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                    char **brokerLinkName_val_ptr_ptr,
                    size_t *brokerLinkName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkName_val_ptr_ptr)
                   && (NULL != *brokerLinkName_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkName data.
     * copy (* brokerLinkName_val_ptr_ptr ) data and (* brokerLinkName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkName data
     */
    if ((NULL == (*brokerLinkName_val_ptr_ptr)) ||
        ((*brokerLinkName_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkName_len *
          sizeof(rowreq_ctx->data.brokerLinkName[0])))) {
        /*
         * allocate space for brokerLinkName data
         */
        (*brokerLinkName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkName_len *
                   sizeof(rowreq_ctx->data.brokerLinkName[0]));
        if (NULL == (*brokerLinkName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkName)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkName_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkName_len *
        sizeof(rowreq_ctx->data.brokerLinkName[0]);
    memcpy((*brokerLinkName_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkName,
           rowreq_ctx->data.brokerLinkName_len *
           sizeof(rowreq_ctx->data.brokerLinkName[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkName_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkHost
 * brokerLinkHost is subid 3 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.3
 * Description:
Link host
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkHost data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkHost_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkHost_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkHost.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkHost_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkHost_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkHost_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                    char **brokerLinkHost_val_ptr_ptr,
                    size_t *brokerLinkHost_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkHost_val_ptr_ptr)
                   && (NULL != *brokerLinkHost_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkHost_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkHost_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkHost data.
     * copy (* brokerLinkHost_val_ptr_ptr ) data and (* brokerLinkHost_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkHost data
     */
    if ((NULL == (*brokerLinkHost_val_ptr_ptr)) ||
        ((*brokerLinkHost_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkHost_len *
          sizeof(rowreq_ctx->data.brokerLinkHost[0])))) {
        /*
         * allocate space for brokerLinkHost data
         */
        (*brokerLinkHost_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkHost_len *
                   sizeof(rowreq_ctx->data.brokerLinkHost[0]));
        if (NULL == (*brokerLinkHost_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkHost)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkHost_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkHost_len *
        sizeof(rowreq_ctx->data.brokerLinkHost[0]);
    memcpy((*brokerLinkHost_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkHost,
           rowreq_ctx->data.brokerLinkHost_len *
           sizeof(rowreq_ctx->data.brokerLinkHost[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkHost_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkPort
 * brokerLinkPort is subid 4 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.4
 * Description:
Link port
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Uint16 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerLinkPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkPort_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerLinkPort_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                    long *brokerLinkPort_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerLinkPort_val_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkPort_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkPort data.
     * copy (* brokerLinkPort_val_ptr ) from rowreq_ctx->data
     */
    (*brokerLinkPort_val_ptr) = rowreq_ctx->data.brokerLinkPort;

    return MFD_SUCCESS;
}                               /* brokerLinkPort_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkTransport
 * brokerLinkTransport is subid 5 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.5
 * Description:
Link transport
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkTransport data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkTransport_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkTransport_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkTransport.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkTransport_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkTransport_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkTransport_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                         char **brokerLinkTransport_val_ptr_ptr,
                         size_t *brokerLinkTransport_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkTransport_val_ptr_ptr)
                   && (NULL != *brokerLinkTransport_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkTransport_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkTransport_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkTransport data.
     * copy (* brokerLinkTransport_val_ptr_ptr ) data and (* brokerLinkTransport_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkTransport data
     */
    if ((NULL == (*brokerLinkTransport_val_ptr_ptr)) ||
        ((*brokerLinkTransport_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkTransport_len *
          sizeof(rowreq_ctx->data.brokerLinkTransport[0])))) {
        /*
         * allocate space for brokerLinkTransport data
         */
        (*brokerLinkTransport_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkTransport_len *
                   sizeof(rowreq_ctx->data.brokerLinkTransport[0]));
        if (NULL == (*brokerLinkTransport_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkTransport)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkTransport_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkTransport_len *
        sizeof(rowreq_ctx->data.brokerLinkTransport[0]);
    memcpy((*brokerLinkTransport_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkTransport,
           rowreq_ctx->data.brokerLinkTransport_len *
           sizeof(rowreq_ctx->data.brokerLinkTransport[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkTransport_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkDurable
 * brokerLinkDurable is subid 6 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.6
 * Description:
Link durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerLinkDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerLinkDurable_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                       u_long * brokerLinkDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerLinkDurable_val_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkDurable data.
     * copy (* brokerLinkDurable_val_ptr ) from rowreq_ctx->data
     */
    (*brokerLinkDurable_val_ptr) = rowreq_ctx->data.brokerLinkDurable;

    return MFD_SUCCESS;
}                               /* brokerLinkDurable_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkConnectionRef
 * brokerLinkConnectionRef is subid 7 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.7
 * Description:
Link connectionRef
                     Additional info ( nodeType:property, references:Connection )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkConnectionRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkConnectionRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkConnectionRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkConnectionRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkConnectionRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkConnectionRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkConnectionRef_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                             char **brokerLinkConnectionRef_val_ptr_ptr,
                             size_t
                             *brokerLinkConnectionRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkConnectionRef_val_ptr_ptr)
                   && (NULL != *brokerLinkConnectionRef_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkConnectionRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkConnectionRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkConnectionRef data.
     * copy (* brokerLinkConnectionRef_val_ptr_ptr ) data and (* brokerLinkConnectionRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkConnectionRef data
     */
    if ((NULL == (*brokerLinkConnectionRef_val_ptr_ptr)) ||
        ((*brokerLinkConnectionRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkConnectionRef_len *
          sizeof(rowreq_ctx->data.brokerLinkConnectionRef[0])))) {
        /*
         * allocate space for brokerLinkConnectionRef data
         */
        (*brokerLinkConnectionRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkConnectionRef_len *
                   sizeof(rowreq_ctx->data.brokerLinkConnectionRef[0]));
        if (NULL == (*brokerLinkConnectionRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkConnectionRef)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkConnectionRef_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkConnectionRef_len *
        sizeof(rowreq_ctx->data.brokerLinkConnectionRef[0]);
    memcpy((*brokerLinkConnectionRef_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkConnectionRef,
           rowreq_ctx->data.brokerLinkConnectionRef_len *
           sizeof(rowreq_ctx->data.brokerLinkConnectionRef[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkConnectionRef_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkState
 * brokerLinkState is subid 8 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.8
 * Description:
Operational state of the link
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerLinkState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkState_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkState_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkState.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkState_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkState_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkState_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                     char **brokerLinkState_val_ptr_ptr,
                     size_t *brokerLinkState_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkState_val_ptr_ptr)
                   && (NULL != *brokerLinkState_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkState_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkState_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkState data.
     * copy (* brokerLinkState_val_ptr_ptr ) data and (* brokerLinkState_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkState data
     */
    if ((NULL == (*brokerLinkState_val_ptr_ptr)) ||
        ((*brokerLinkState_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkState_len *
          sizeof(rowreq_ctx->data.brokerLinkState[0])))) {
        /*
         * allocate space for brokerLinkState data
         */
        (*brokerLinkState_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkState_len *
                   sizeof(rowreq_ctx->data.brokerLinkState[0]));
        if (NULL == (*brokerLinkState_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkState)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkState_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkState_len *
        sizeof(rowreq_ctx->data.brokerLinkState[0]);
    memcpy((*brokerLinkState_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkState,
           rowreq_ctx->data.brokerLinkState_len *
           sizeof(rowreq_ctx->data.brokerLinkState[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkState_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerLinkEntry.brokerLinkLastError
 * brokerLinkLastError is subid 9 of brokerLinkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.11.1.1.9
 * Description:
Reason link is not operational
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Lstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the brokerLinkLastError data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerLinkLastError_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerLinkLastError_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerLinkLastError.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerLinkLastError_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerLinkLastError_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerLinkLastError_get(brokerLinkTable_rowreq_ctx * rowreq_ctx,
                         char **brokerLinkLastError_val_ptr_ptr,
                         size_t *brokerLinkLastError_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerLinkLastError_val_ptr_ptr)
                   && (NULL != *brokerLinkLastError_val_ptr_ptr));
    netsnmp_assert(NULL != brokerLinkLastError_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerLinkTable:brokerLinkLastError_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerLinkLastError data.
     * copy (* brokerLinkLastError_val_ptr_ptr ) data and (* brokerLinkLastError_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerLinkLastError data
     */
    if ((NULL == (*brokerLinkLastError_val_ptr_ptr)) ||
        ((*brokerLinkLastError_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerLinkLastError_len *
          sizeof(rowreq_ctx->data.brokerLinkLastError[0])))) {
        /*
         * allocate space for brokerLinkLastError data
         */
        (*brokerLinkLastError_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerLinkLastError_len *
                   sizeof(rowreq_ctx->data.brokerLinkLastError[0]));
        if (NULL == (*brokerLinkLastError_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerLinkLastError)\n");
            return MFD_ERROR;
        }
    }
    (*brokerLinkLastError_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerLinkLastError_len *
        sizeof(rowreq_ctx->data.brokerLinkLastError[0]);
    memcpy((*brokerLinkLastError_val_ptr_ptr),
           rowreq_ctx->data.brokerLinkLastError,
           rowreq_ctx->data.brokerLinkLastError_len *
           sizeof(rowreq_ctx->data.brokerLinkLastError[0]));

    return MFD_SUCCESS;
}                               /* brokerLinkLastError_get */



/** @} */
