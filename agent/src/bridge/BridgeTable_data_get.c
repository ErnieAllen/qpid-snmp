/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "BridgeTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement brokerBridgeTable get routines.
 * TODO:240:M: Implement brokerBridgeTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table brokerBridgeTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * QPID-MESSAGING-MIB::brokerBridgeTable is subid 1 of brokerBridges.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1, length: 11
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement brokerBridgeTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param brokerBridgeInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
brokerBridgeTable_indexes_set_tbl_idx(brokerBridgeTable_mib_index *
                                      tbl_idx,
                                      u_long brokerBridgeInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeTable_indexes_set_tbl_idx", "called\n"));

    /*
     * brokerBridgeInternalIndex(14)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->brokerBridgeInternalIndex = brokerBridgeInternalIndex_val;


    return MFD_SUCCESS;
}                               /* brokerBridgeTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
brokerBridgeTable_indexes_set(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                              u_long brokerBridgeInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        brokerBridgeTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                              brokerBridgeInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != brokerBridgeTable_index_to_oid(&rowreq_ctx->oid_idx,
                                            &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* brokerBridgeTable_indexes_set */


/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeLinkRef
 * brokerBridgeLinkRef is subid 1 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.1
 * Description:
Bridge linkRef
                     Additional info ( nodeType:property, references:Link, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeLinkRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeLinkRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeLinkRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeLinkRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeLinkRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeLinkRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeLinkRef_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                        char **brokerBridgeLinkRef_val_ptr_ptr,
                        size_t *brokerBridgeLinkRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeLinkRef_val_ptr_ptr)
                   && (NULL != *brokerBridgeLinkRef_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeLinkRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeLinkRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeLinkRef data.
     * copy (* brokerBridgeLinkRef_val_ptr_ptr ) data and (* brokerBridgeLinkRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeLinkRef data
     */
    if ((NULL == (*brokerBridgeLinkRef_val_ptr_ptr)) ||
        ((*brokerBridgeLinkRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeLinkRef_len *
          sizeof(rowreq_ctx->data.brokerBridgeLinkRef[0])))) {
        /*
         * allocate space for brokerBridgeLinkRef data
         */
        (*brokerBridgeLinkRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeLinkRef_len *
                   sizeof(rowreq_ctx->data.brokerBridgeLinkRef[0]));
        if (NULL == (*brokerBridgeLinkRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeLinkRef)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeLinkRef_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeLinkRef_len *
        sizeof(rowreq_ctx->data.brokerBridgeLinkRef[0]);
    memcpy((*brokerBridgeLinkRef_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeLinkRef,
           rowreq_ctx->data.brokerBridgeLinkRef_len *
           sizeof(rowreq_ctx->data.brokerBridgeLinkRef[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeLinkRef_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeName
 * brokerBridgeName is subid 2 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.2
 * Description:
Bridge name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeName_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                     char **brokerBridgeName_val_ptr_ptr,
                     size_t *brokerBridgeName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeName_val_ptr_ptr)
                   && (NULL != *brokerBridgeName_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeName data.
     * copy (* brokerBridgeName_val_ptr_ptr ) data and (* brokerBridgeName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeName data
     */
    if ((NULL == (*brokerBridgeName_val_ptr_ptr)) ||
        ((*brokerBridgeName_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeName_len *
          sizeof(rowreq_ctx->data.brokerBridgeName[0])))) {
        /*
         * allocate space for brokerBridgeName data
         */
        (*brokerBridgeName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeName_len *
                   sizeof(rowreq_ctx->data.brokerBridgeName[0]));
        if (NULL == (*brokerBridgeName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeName)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeName_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeName_len *
        sizeof(rowreq_ctx->data.brokerBridgeName[0]);
    memcpy((*brokerBridgeName_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeName,
           rowreq_ctx->data.brokerBridgeName_len *
           sizeof(rowreq_ctx->data.brokerBridgeName[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeName_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeChannelId
 * brokerBridgeChannelId is subid 3 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.3
 * Description:
Bridge channelId
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Uint16 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerBridgeChannelId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeChannelId_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeChannelId_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                          long *brokerBridgeChannelId_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeChannelId_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeChannelId_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeChannelId data.
     * copy (* brokerBridgeChannelId_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeChannelId_val_ptr) =
        rowreq_ctx->data.brokerBridgeChannelId;

    return MFD_SUCCESS;
}                               /* brokerBridgeChannelId_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeDurable
 * brokerBridgeDurable is subid 4 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.4
 * Description:
Bridge durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerBridgeDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeDurable_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                        u_long * brokerBridgeDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeDurable_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeDurable data.
     * copy (* brokerBridgeDurable_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeDurable_val_ptr) = rowreq_ctx->data.brokerBridgeDurable;

    return MFD_SUCCESS;
}                               /* brokerBridgeDurable_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeSrc
 * brokerBridgeSrc is subid 5 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.5
 * Description:
Bridge src
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeSrc data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeSrc_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeSrc_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeSrc.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeSrc_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeSrc_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeSrc_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                    char **brokerBridgeSrc_val_ptr_ptr,
                    size_t *brokerBridgeSrc_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeSrc_val_ptr_ptr)
                   && (NULL != *brokerBridgeSrc_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeSrc_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeSrc_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeSrc data.
     * copy (* brokerBridgeSrc_val_ptr_ptr ) data and (* brokerBridgeSrc_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeSrc data
     */
    if ((NULL == (*brokerBridgeSrc_val_ptr_ptr)) ||
        ((*brokerBridgeSrc_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeSrc_len *
          sizeof(rowreq_ctx->data.brokerBridgeSrc[0])))) {
        /*
         * allocate space for brokerBridgeSrc data
         */
        (*brokerBridgeSrc_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeSrc_len *
                   sizeof(rowreq_ctx->data.brokerBridgeSrc[0]));
        if (NULL == (*brokerBridgeSrc_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeSrc)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeSrc_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeSrc_len *
        sizeof(rowreq_ctx->data.brokerBridgeSrc[0]);
    memcpy((*brokerBridgeSrc_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeSrc,
           rowreq_ctx->data.brokerBridgeSrc_len *
           sizeof(rowreq_ctx->data.brokerBridgeSrc[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeSrc_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeDest
 * brokerBridgeDest is subid 6 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.6
 * Description:
Bridge dest
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeDest data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeDest_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeDest_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeDest.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeDest_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeDest_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeDest_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                     char **brokerBridgeDest_val_ptr_ptr,
                     size_t *brokerBridgeDest_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeDest_val_ptr_ptr)
                   && (NULL != *brokerBridgeDest_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeDest_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeDest_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeDest data.
     * copy (* brokerBridgeDest_val_ptr_ptr ) data and (* brokerBridgeDest_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeDest data
     */
    if ((NULL == (*brokerBridgeDest_val_ptr_ptr)) ||
        ((*brokerBridgeDest_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeDest_len *
          sizeof(rowreq_ctx->data.brokerBridgeDest[0])))) {
        /*
         * allocate space for brokerBridgeDest data
         */
        (*brokerBridgeDest_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeDest_len *
                   sizeof(rowreq_ctx->data.brokerBridgeDest[0]));
        if (NULL == (*brokerBridgeDest_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeDest)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeDest_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeDest_len *
        sizeof(rowreq_ctx->data.brokerBridgeDest[0]);
    memcpy((*brokerBridgeDest_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeDest,
           rowreq_ctx->data.brokerBridgeDest_len *
           sizeof(rowreq_ctx->data.brokerBridgeDest[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeDest_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeKey
 * brokerBridgeKey is subid 7 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.7
 * Description:
Bridge key
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Lstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the brokerBridgeKey data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeKey_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeKey_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeKey.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeKey_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeKey_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeKey_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                    char **brokerBridgeKey_val_ptr_ptr,
                    size_t *brokerBridgeKey_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeKey_val_ptr_ptr)
                   && (NULL != *brokerBridgeKey_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeKey_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeKey_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeKey data.
     * copy (* brokerBridgeKey_val_ptr_ptr ) data and (* brokerBridgeKey_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeKey data
     */
    if ((NULL == (*brokerBridgeKey_val_ptr_ptr)) ||
        ((*brokerBridgeKey_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeKey_len *
          sizeof(rowreq_ctx->data.brokerBridgeKey[0])))) {
        /*
         * allocate space for brokerBridgeKey data
         */
        (*brokerBridgeKey_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeKey_len *
                   sizeof(rowreq_ctx->data.brokerBridgeKey[0]));
        if (NULL == (*brokerBridgeKey_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeKey)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeKey_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeKey_len *
        sizeof(rowreq_ctx->data.brokerBridgeKey[0]);
    memcpy((*brokerBridgeKey_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeKey,
           rowreq_ctx->data.brokerBridgeKey_len *
           sizeof(rowreq_ctx->data.brokerBridgeKey[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeKey_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeSrcIsQueue
 * brokerBridgeSrcIsQueue is subid 8 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.8
 * Description:
Bridge srcIsQueue
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerBridgeSrcIsQueue data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeSrcIsQueue_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeSrcIsQueue_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                           u_long * brokerBridgeSrcIsQueue_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeSrcIsQueue_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeSrcIsQueue_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeSrcIsQueue data.
     * copy (* brokerBridgeSrcIsQueue_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeSrcIsQueue_val_ptr) =
        rowreq_ctx->data.brokerBridgeSrcIsQueue;

    return MFD_SUCCESS;
}                               /* brokerBridgeSrcIsQueue_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeSrcIsLocal
 * brokerBridgeSrcIsLocal is subid 9 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.9
 * Description:
Bridge srcIsLocal
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerBridgeSrcIsLocal data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeSrcIsLocal_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeSrcIsLocal_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                           u_long * brokerBridgeSrcIsLocal_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeSrcIsLocal_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeSrcIsLocal_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeSrcIsLocal data.
     * copy (* brokerBridgeSrcIsLocal_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeSrcIsLocal_val_ptr) =
        rowreq_ctx->data.brokerBridgeSrcIsLocal;

    return MFD_SUCCESS;
}                               /* brokerBridgeSrcIsLocal_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeTag
 * brokerBridgeTag is subid 10 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.10
 * Description:
Bridge tag
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeTag data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeTag_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeTag_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeTag.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeTag_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeTag_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeTag_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                    char **brokerBridgeTag_val_ptr_ptr,
                    size_t *brokerBridgeTag_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeTag_val_ptr_ptr)
                   && (NULL != *brokerBridgeTag_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeTag_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeTag_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeTag data.
     * copy (* brokerBridgeTag_val_ptr_ptr ) data and (* brokerBridgeTag_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeTag data
     */
    if ((NULL == (*brokerBridgeTag_val_ptr_ptr)) ||
        ((*brokerBridgeTag_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeTag_len *
          sizeof(rowreq_ctx->data.brokerBridgeTag[0])))) {
        /*
         * allocate space for brokerBridgeTag data
         */
        (*brokerBridgeTag_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeTag_len *
                   sizeof(rowreq_ctx->data.brokerBridgeTag[0]));
        if (NULL == (*brokerBridgeTag_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeTag)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeTag_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeTag_len *
        sizeof(rowreq_ctx->data.brokerBridgeTag[0]);
    memcpy((*brokerBridgeTag_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeTag,
           rowreq_ctx->data.brokerBridgeTag_len *
           sizeof(rowreq_ctx->data.brokerBridgeTag[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeTag_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeExcludes
 * brokerBridgeExcludes is subid 11 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.11
 * Description:
Bridge excludes
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerBridgeExcludes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeExcludes_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerBridgeExcludes_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerBridgeExcludes.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerBridgeExcludes_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerBridgeExcludes_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerBridgeExcludes_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                         char **brokerBridgeExcludes_val_ptr_ptr,
                         size_t *brokerBridgeExcludes_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerBridgeExcludes_val_ptr_ptr)
                   && (NULL != *brokerBridgeExcludes_val_ptr_ptr));
    netsnmp_assert(NULL != brokerBridgeExcludes_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeExcludes_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeExcludes data.
     * copy (* brokerBridgeExcludes_val_ptr_ptr ) data and (* brokerBridgeExcludes_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerBridgeExcludes data
     */
    if ((NULL == (*brokerBridgeExcludes_val_ptr_ptr)) ||
        ((*brokerBridgeExcludes_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerBridgeExcludes_len *
          sizeof(rowreq_ctx->data.brokerBridgeExcludes[0])))) {
        /*
         * allocate space for brokerBridgeExcludes data
         */
        (*brokerBridgeExcludes_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerBridgeExcludes_len *
                   sizeof(rowreq_ctx->data.brokerBridgeExcludes[0]));
        if (NULL == (*brokerBridgeExcludes_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerBridgeExcludes)\n");
            return MFD_ERROR;
        }
    }
    (*brokerBridgeExcludes_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerBridgeExcludes_len *
        sizeof(rowreq_ctx->data.brokerBridgeExcludes[0]);
    memcpy((*brokerBridgeExcludes_val_ptr_ptr),
           rowreq_ctx->data.brokerBridgeExcludes,
           rowreq_ctx->data.brokerBridgeExcludes_len *
           sizeof(rowreq_ctx->data.brokerBridgeExcludes[0]));

    return MFD_SUCCESS;
}                               /* brokerBridgeExcludes_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeDynamic
 * brokerBridgeDynamic is subid 12 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.12
 * Description:
Bridge dynamic
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerBridgeDynamic data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeDynamic_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeDynamic_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                        u_long * brokerBridgeDynamic_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeDynamic_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeDynamic_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeDynamic data.
     * copy (* brokerBridgeDynamic_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeDynamic_val_ptr) = rowreq_ctx->data.brokerBridgeDynamic;

    return MFD_SUCCESS;
}                               /* brokerBridgeDynamic_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerBridgeEntry.brokerBridgeSync
 * brokerBridgeSync is subid 13 of brokerBridgeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.12.1.1.13
 * Description:
Bridge sync
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: d
 *
 *
 * Its syntax is Uint16 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerBridgeSync data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerBridgeSync_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerBridgeSync_get(brokerBridgeTable_rowreq_ctx * rowreq_ctx,
                     long *brokerBridgeSync_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerBridgeSync_val_ptr);


    DEBUGMSGTL(("verbose:brokerBridgeTable:brokerBridgeSync_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerBridgeSync data.
     * copy (* brokerBridgeSync_val_ptr ) from rowreq_ctx->data
     */
    (*brokerBridgeSync_val_ptr) = rowreq_ctx->data.brokerBridgeSync;

    return MFD_SUCCESS;
}                               /* brokerBridgeSync_get */



/** @} */
