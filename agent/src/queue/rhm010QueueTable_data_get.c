/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "rhm010QueueTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement rhm010QueueTable get routines.
 * TODO:240:M: Implement rhm010QueueTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table rhm010QueueTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * MRG-MESSAGING-MIB::rhm010QueueTable is subid 1 of rhm010Queues.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement rhm010QueueTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param rhm010QueueInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
rhm010QueueTable_indexes_set_tbl_idx(rhm010QueueTable_mib_index * tbl_idx,
                                     u_long rhm010QueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueTable_indexes_set_tbl_idx", "called\n"));

    /*
     * rhm010QueueInternalIndex(49)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->rhm010QueueInternalIndex = rhm010QueueInternalIndex_val;


    return MFD_SUCCESS;
}                               /* rhm010QueueTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
rhm010QueueTable_indexes_set(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                             u_long rhm010QueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        rhm010QueueTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                             rhm010QueueInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != rhm010QueueTable_index_to_oid(&rowreq_ctx->oid_idx,
                                           &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* rhm010QueueTable_indexes_set */


/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueVhostRef
 * rhm010QueueVhostRef is subid 1 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.1
 * Description:
Queue vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010QueueVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010QueueVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010QueueVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010QueueVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010QueueVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010QueueVhostRef_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                        char **rhm010QueueVhostRef_val_ptr_ptr,
                        size_t *rhm010QueueVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010QueueVhostRef_val_ptr_ptr)
                   && (NULL != *rhm010QueueVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010QueueVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueVhostRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueVhostRef data.
     * copy (* rhm010QueueVhostRef_val_ptr_ptr ) data and (* rhm010QueueVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010QueueVhostRef data
     */
    if ((NULL == (*rhm010QueueVhostRef_val_ptr_ptr)) ||
        ((*rhm010QueueVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010QueueVhostRef_len *
          sizeof(rowreq_ctx->data.rhm010QueueVhostRef[0])))) {
        /*
         * allocate space for rhm010QueueVhostRef data
         */
        (*rhm010QueueVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010QueueVhostRef_len *
                   sizeof(rowreq_ctx->data.rhm010QueueVhostRef[0]));
        if (NULL == (*rhm010QueueVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010QueueVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010QueueVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010QueueVhostRef_len *
        sizeof(rowreq_ctx->data.rhm010QueueVhostRef[0]);
    memcpy((*rhm010QueueVhostRef_val_ptr_ptr),
           rowreq_ctx->data.rhm010QueueVhostRef,
           rowreq_ctx->data.rhm010QueueVhostRef_len *
           sizeof(rowreq_ctx->data.rhm010QueueVhostRef[0]));

    return MFD_SUCCESS;
}                               /* rhm010QueueVhostRef_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueName
 * rhm010QueueName is subid 2 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.2
 * Description:
Queue name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010QueueName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010QueueName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010QueueName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010QueueName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010QueueName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010QueueName_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                    char **rhm010QueueName_val_ptr_ptr,
                    size_t *rhm010QueueName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010QueueName_val_ptr_ptr)
                   && (NULL != *rhm010QueueName_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010QueueName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueName data.
     * copy (* rhm010QueueName_val_ptr_ptr ) data and (* rhm010QueueName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010QueueName data
     */
    if ((NULL == (*rhm010QueueName_val_ptr_ptr)) ||
        ((*rhm010QueueName_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010QueueName_len *
          sizeof(rowreq_ctx->data.rhm010QueueName[0])))) {
        /*
         * allocate space for rhm010QueueName data
         */
        (*rhm010QueueName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010QueueName_len *
                   sizeof(rowreq_ctx->data.rhm010QueueName[0]));
        if (NULL == (*rhm010QueueName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010QueueName)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010QueueName_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010QueueName_len *
        sizeof(rowreq_ctx->data.rhm010QueueName[0]);
    memcpy((*rhm010QueueName_val_ptr_ptr),
           rowreq_ctx->data.rhm010QueueName,
           rowreq_ctx->data.rhm010QueueName_len *
           sizeof(rowreq_ctx->data.rhm010QueueName[0]));

    return MFD_SUCCESS;
}                               /* rhm010QueueName_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDurable
 * rhm010QueueDurable is subid 3 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.3
 * Description:
Queue durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDurable_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                       u_long * rhm010QueueDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDurable_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueDurable data.
     * copy (* rhm010QueueDurable_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueDurable_val_ptr) = rowreq_ctx->data.rhm010QueueDurable;

    return MFD_SUCCESS;
}                               /* rhm010QueueDurable_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueAutoDelete
 * rhm010QueueAutoDelete is subid 4 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.4
 * Description:
Queue autoDelete
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueAutoDelete data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueAutoDelete_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueAutoDelete_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                          u_long * rhm010QueueAutoDelete_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueAutoDelete_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueAutoDelete_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueAutoDelete data.
     * copy (* rhm010QueueAutoDelete_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueAutoDelete_val_ptr) =
        rowreq_ctx->data.rhm010QueueAutoDelete;

    return MFD_SUCCESS;
}                               /* rhm010QueueAutoDelete_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueExclusive
 * rhm010QueueExclusive is subid 5 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.5
 * Description:
Queue exclusive
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueExclusive data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueExclusive_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueExclusive_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                         u_long * rhm010QueueExclusive_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueExclusive_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueExclusive_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueExclusive data.
     * copy (* rhm010QueueExclusive_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueExclusive_val_ptr) =
        rowreq_ctx->data.rhm010QueueExclusive;

    return MFD_SUCCESS;
}                               /* rhm010QueueExclusive_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueArguments
 * rhm010QueueArguments is subid 6 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.6
 * Description:
Arguments supplied in queue.declare
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Map (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the rhm010QueueArguments data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueArguments_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010QueueArguments_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010QueueArguments.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010QueueArguments_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010QueueArguments_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010QueueArguments_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                         char **rhm010QueueArguments_val_ptr_ptr,
                         size_t *rhm010QueueArguments_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010QueueArguments_val_ptr_ptr)
                   && (NULL != *rhm010QueueArguments_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010QueueArguments_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueArguments_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueArguments data.
     * copy (* rhm010QueueArguments_val_ptr_ptr ) data and (* rhm010QueueArguments_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010QueueArguments data
     */
    if ((NULL == (*rhm010QueueArguments_val_ptr_ptr)) ||
        ((*rhm010QueueArguments_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010QueueArguments_len *
          sizeof(rowreq_ctx->data.rhm010QueueArguments[0])))) {
        /*
         * allocate space for rhm010QueueArguments data
         */
        (*rhm010QueueArguments_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010QueueArguments_len *
                   sizeof(rowreq_ctx->data.rhm010QueueArguments[0]));
        if (NULL == (*rhm010QueueArguments_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010QueueArguments)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010QueueArguments_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010QueueArguments_len *
        sizeof(rowreq_ctx->data.rhm010QueueArguments[0]);
    memcpy((*rhm010QueueArguments_val_ptr_ptr),
           rowreq_ctx->data.rhm010QueueArguments,
           rowreq_ctx->data.rhm010QueueArguments_len *
           sizeof(rowreq_ctx->data.rhm010QueueArguments[0]));

    return MFD_SUCCESS;
}                               /* rhm010QueueArguments_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueAltExchange
 * rhm010QueueAltExchange is subid 7 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.7
 * Description:
Queue altExchange
                     Additional info ( nodeType:property, references:Exchange, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the rhm010QueueAltExchange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueAltExchange_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param rhm010QueueAltExchange_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by rhm010QueueAltExchange.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*rhm010QueueAltExchange_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update rhm010QueueAltExchange_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
rhm010QueueAltExchange_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                           char **rhm010QueueAltExchange_val_ptr_ptr,
                           size_t *rhm010QueueAltExchange_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != rhm010QueueAltExchange_val_ptr_ptr)
                   && (NULL != *rhm010QueueAltExchange_val_ptr_ptr));
    netsnmp_assert(NULL != rhm010QueueAltExchange_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueAltExchange_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueAltExchange data.
     * copy (* rhm010QueueAltExchange_val_ptr_ptr ) data and (* rhm010QueueAltExchange_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for rhm010QueueAltExchange data
     */
    if ((NULL == (*rhm010QueueAltExchange_val_ptr_ptr)) ||
        ((*rhm010QueueAltExchange_val_ptr_len_ptr) <
         (rowreq_ctx->data.rhm010QueueAltExchange_len *
          sizeof(rowreq_ctx->data.rhm010QueueAltExchange[0])))) {
        /*
         * allocate space for rhm010QueueAltExchange data
         */
        (*rhm010QueueAltExchange_val_ptr_ptr) =
            malloc(rowreq_ctx->data.rhm010QueueAltExchange_len *
                   sizeof(rowreq_ctx->data.rhm010QueueAltExchange[0]));
        if (NULL == (*rhm010QueueAltExchange_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.rhm010QueueAltExchange)\n");
            return MFD_ERROR;
        }
    }
    (*rhm010QueueAltExchange_val_ptr_len_ptr) =
        rowreq_ctx->data.rhm010QueueAltExchange_len *
        sizeof(rowreq_ctx->data.rhm010QueueAltExchange[0]);
    memcpy((*rhm010QueueAltExchange_val_ptr_ptr),
           rowreq_ctx->data.rhm010QueueAltExchange,
           rowreq_ctx->data.rhm010QueueAltExchange_len *
           sizeof(rowreq_ctx->data.rhm010QueueAltExchange[0]));

    return MFD_SUCCESS;
}                               /* rhm010QueueAltExchange_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgTotalEnqueues
 * rhm010QueueMsgTotalEnqueues is subid 8 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.8
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgTotalEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * rhm010QueueMsgTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgTotalEnqueues data.
     * get (* rhm010QueueMsgTotalEnqueues_val_ptr ).low and (* rhm010QueueMsgTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgTotalEnqueues.high;
    (*rhm010QueueMsgTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgTotalEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgTotalDequeues
 * rhm010QueueMsgTotalDequeues is subid 9 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.9
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgTotalDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * rhm010QueueMsgTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgTotalDequeues data.
     * get (* rhm010QueueMsgTotalDequeues_val_ptr ).low and (* rhm010QueueMsgTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgTotalDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgTotalDequeues.high;
    (*rhm010QueueMsgTotalDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgTotalDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgTxnEnqueues
 * rhm010QueueMsgTxnEnqueues is subid 10 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.10
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgTxnEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * rhm010QueueMsgTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgTxnEnqueues data.
     * get (* rhm010QueueMsgTxnEnqueues_val_ptr ).low and (* rhm010QueueMsgTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgTxnEnqueues.high;
    (*rhm010QueueMsgTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgTxnEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgTxnDequeues
 * rhm010QueueMsgTxnDequeues is subid 11 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.11
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgTxnDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * rhm010QueueMsgTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgTxnDequeues data.
     * get (* rhm010QueueMsgTxnDequeues_val_ptr ).low and (* rhm010QueueMsgTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgTxnDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgTxnDequeues.high;
    (*rhm010QueueMsgTxnDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgTxnDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgPersistEnqueues
 * rhm010QueueMsgPersistEnqueues is subid 12 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.12
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgPersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgPersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgPersistEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  rhm010QueueMsgPersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgPersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgPersistEnqueues data.
     * get (* rhm010QueueMsgPersistEnqueues_val_ptr ).low and (* rhm010QueueMsgPersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgPersistEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgPersistEnqueues.high;
    (*rhm010QueueMsgPersistEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgPersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgPersistEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgPersistDequeues
 * rhm010QueueMsgPersistDequeues is subid 13 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.13
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgPersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgPersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgPersistDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  rhm010QueueMsgPersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgPersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgPersistDequeues data.
     * get (* rhm010QueueMsgPersistDequeues_val_ptr ).low and (* rhm010QueueMsgPersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgPersistDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgPersistDequeues.high;
    (*rhm010QueueMsgPersistDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgPersistDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgPersistDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgDepth
 * rhm010QueueMsgDepth is subid 14 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.14
 * Description:
Current size of queue in messages
                     Additional info ( nodeType:statistic, assign:msgTotalEnqueues - msgTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgDepth_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * rhm010QueueMsgDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgDepth data.
     * get (* rhm010QueueMsgDepth_val_ptr ).low and (* rhm010QueueMsgDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgDepth_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgDepth.high;
    (*rhm010QueueMsgDepth_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgDepth.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteDepth
 * rhm010QueueByteDepth is subid 15 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.15
 * Description:
Current size of queue in bytes
                     Additional info ( nodeType:statistic, assign:byteTotalEnqueues - byteTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteDepth_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                         U64 * rhm010QueueByteDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteDepth data.
     * get (* rhm010QueueByteDepth_val_ptr ).low and (* rhm010QueueByteDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteDepth_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteDepth.high;
    (*rhm010QueueByteDepth_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteDepth.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteTotalEnqueues
 * rhm010QueueByteTotalEnqueues is subid 16 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.16
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteTotalEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 rhm010QueueByteTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteTotalEnqueues data.
     * get (* rhm010QueueByteTotalEnqueues_val_ptr ).low and (* rhm010QueueByteTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteTotalEnqueues.high;
    (*rhm010QueueByteTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteTotalEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteTotalDequeues
 * rhm010QueueByteTotalDequeues is subid 17 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.17
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteTotalDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 rhm010QueueByteTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteTotalDequeues data.
     * get (* rhm010QueueByteTotalDequeues_val_ptr ).low and (* rhm010QueueByteTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteTotalDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteTotalDequeues.high;
    (*rhm010QueueByteTotalDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteTotalDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteTxnEnqueues
 * rhm010QueueByteTxnEnqueues is subid 18 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.18
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteTxnEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * rhm010QueueByteTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteTxnEnqueues data.
     * get (* rhm010QueueByteTxnEnqueues_val_ptr ).low and (* rhm010QueueByteTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteTxnEnqueues.high;
    (*rhm010QueueByteTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteTxnEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteTxnDequeues
 * rhm010QueueByteTxnDequeues is subid 19 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.19
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteTxnDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * rhm010QueueByteTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteTxnDequeues data.
     * get (* rhm010QueueByteTxnDequeues_val_ptr ).low and (* rhm010QueueByteTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteTxnDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteTxnDequeues.high;
    (*rhm010QueueByteTxnDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteTxnDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueBytePersistEnqueues
 * rhm010QueueBytePersistEnqueues is subid 20 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.20
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueBytePersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueBytePersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueBytePersistEnqueues_get(rhm010QueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   rhm010QueueBytePersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueBytePersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueBytePersistEnqueues data.
     * get (* rhm010QueueBytePersistEnqueues_val_ptr ).low and (* rhm010QueueBytePersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueBytePersistEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueBytePersistEnqueues.high;
    (*rhm010QueueBytePersistEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueBytePersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueBytePersistEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueBytePersistDequeues
 * rhm010QueueBytePersistDequeues is subid 21 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.21
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueBytePersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueBytePersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueBytePersistDequeues_get(rhm010QueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   rhm010QueueBytePersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueBytePersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueBytePersistDequeues data.
     * get (* rhm010QueueBytePersistDequeues_val_ptr ).low and (* rhm010QueueBytePersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueBytePersistDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueBytePersistDequeues.high;
    (*rhm010QueueBytePersistDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueBytePersistDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueBytePersistDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgFtdEnqueues
 * rhm010QueueMsgFtdEnqueues is subid 22 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.22
 * Description:
Total message bodies released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgFtdEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * rhm010QueueMsgFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgFtdEnqueues data.
     * get (* rhm010QueueMsgFtdEnqueues_val_ptr ).low and (* rhm010QueueMsgFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgFtdEnqueues.high;
    (*rhm010QueueMsgFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgFtdEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgFtdDequeues
 * rhm010QueueMsgFtdDequeues is subid 23 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.23
 * Description:
Total message bodies dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgFtdDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * rhm010QueueMsgFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgFtdDequeues data.
     * get (* rhm010QueueMsgFtdDequeues_val_ptr ).low and (* rhm010QueueMsgFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgFtdDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgFtdDequeues.high;
    (*rhm010QueueMsgFtdDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgFtdDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteFtdEnqueues
 * rhm010QueueByteFtdEnqueues is subid 24 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.24
 * Description:
Total bytes released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteFtdEnqueues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * rhm010QueueByteFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteFtdEnqueues data.
     * get (* rhm010QueueByteFtdEnqueues_val_ptr ).low and (* rhm010QueueByteFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteFtdEnqueues.high;
    (*rhm010QueueByteFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteFtdEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteFtdDequeues
 * rhm010QueueByteFtdDequeues is subid 25 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.25
 * Description:
Total bytes dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteFtdDequeues_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * rhm010QueueByteFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteFtdDequeues data.
     * get (* rhm010QueueByteFtdDequeues_val_ptr ).low and (* rhm010QueueByteFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteFtdDequeues_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteFtdDequeues.high;
    (*rhm010QueueByteFtdDequeues_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteFtdDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMsgFtdDepth
 * rhm010QueueMsgFtdDepth is subid 26 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.26
 * Description:
Current number of messages flowed-to-disk
                     Additional info ( nodeType:statistic, assign:msgFtdEnqueues - msgFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueMsgFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMsgFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMsgFtdDepth_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * rhm010QueueMsgFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMsgFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueMsgFtdDepth data.
     * get (* rhm010QueueMsgFtdDepth_val_ptr ).low and (* rhm010QueueMsgFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueMsgFtdDepth_val_ptr).high =
        rowreq_ctx->data.rhm010QueueMsgFtdDepth.high;
    (*rhm010QueueMsgFtdDepth_val_ptr).low =
        rowreq_ctx->data.rhm010QueueMsgFtdDepth.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueMsgFtdDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueByteFtdDepth
 * rhm010QueueByteFtdDepth is subid 27 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.27
 * Description:
Current number of bytes flowed-to-disk
                     Additional info ( nodeType:statistic, assign:byteFtdEnqueues - byteFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueByteFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueByteFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueByteFtdDepth_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * rhm010QueueByteFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueByteFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueByteFtdDepth data.
     * get (* rhm010QueueByteFtdDepth_val_ptr ).low and (* rhm010QueueByteFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueByteFtdDepth_val_ptr).high =
        rowreq_ctx->data.rhm010QueueByteFtdDepth.high;
    (*rhm010QueueByteFtdDepth_val_ptr).low =
        rowreq_ctx->data.rhm010QueueByteFtdDepth.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueByteFtdDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueReleases
 * rhm010QueueReleases is subid 28 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.28
 * Description:
Acquired messages reinserted into the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueReleases data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueReleases_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueReleases_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * rhm010QueueReleases_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueReleases_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueReleases data.
     * get (* rhm010QueueReleases_val_ptr ).low and (* rhm010QueueReleases_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueReleases_val_ptr).high =
        rowreq_ctx->data.rhm010QueueReleases.high;
    (*rhm010QueueReleases_val_ptr).low =
        rowreq_ctx->data.rhm010QueueReleases.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueReleases_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueAcquires
 * rhm010QueueAcquires is subid 29 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.29
 * Description:
Messages acquired from the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueAcquires data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueAcquires_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueAcquires_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * rhm010QueueAcquires_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueAcquires_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueAcquires data.
     * get (* rhm010QueueAcquires_val_ptr ).low and (* rhm010QueueAcquires_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueAcquires_val_ptr).high =
        rowreq_ctx->data.rhm010QueueAcquires.high;
    (*rhm010QueueAcquires_val_ptr).low =
        rowreq_ctx->data.rhm010QueueAcquires.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueAcquires_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsTtl
 * rhm010QueueDiscardsTtl is subid 30 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.30
 * Description:
Messages discarded due to TTL expiration
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsTtl data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsTtl_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsTtl_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * rhm010QueueDiscardsTtl_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsTtl_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsTtl data.
     * get (* rhm010QueueDiscardsTtl_val_ptr ).low and (* rhm010QueueDiscardsTtl_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsTtl_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsTtl.high;
    (*rhm010QueueDiscardsTtl_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsTtl.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsTtl_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsRing
 * rhm010QueueDiscardsRing is subid 31 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.31
 * Description:
Messages discarded due to ring-queue overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsRing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsRing_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsRing_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * rhm010QueueDiscardsRing_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsRing_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsRing data.
     * get (* rhm010QueueDiscardsRing_val_ptr ).low and (* rhm010QueueDiscardsRing_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsRing_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsRing.high;
    (*rhm010QueueDiscardsRing_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsRing.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsRing_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsLvq
 * rhm010QueueDiscardsLvq is subid 32 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.32
 * Description:
Messages discarded due to LVQ insert
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsLvq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsLvq_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsLvq_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * rhm010QueueDiscardsLvq_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsLvq_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsLvq data.
     * get (* rhm010QueueDiscardsLvq_val_ptr ).low and (* rhm010QueueDiscardsLvq_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsLvq_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsLvq.high;
    (*rhm010QueueDiscardsLvq_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsLvq.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsLvq_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsOverflow
 * rhm010QueueDiscardsOverflow is subid 33 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.33
 * Description:
Messages discarded due to reject-policy overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsOverflow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsOverflow_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsOverflow_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * rhm010QueueDiscardsOverflow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsOverflow_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsOverflow data.
     * get (* rhm010QueueDiscardsOverflow_val_ptr ).low and (* rhm010QueueDiscardsOverflow_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsOverflow_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsOverflow.high;
    (*rhm010QueueDiscardsOverflow_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsOverflow.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsOverflow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsSubscriber
 * rhm010QueueDiscardsSubscriber is subid 34 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.34
 * Description:
Messages discarded due to subscriber reject
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsSubscriber data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsSubscriber_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsSubscriber_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  rhm010QueueDiscardsSubscriber_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsSubscriber_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsSubscriber data.
     * get (* rhm010QueueDiscardsSubscriber_val_ptr ).low and (* rhm010QueueDiscardsSubscriber_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsSubscriber_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsSubscriber.high;
    (*rhm010QueueDiscardsSubscriber_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsSubscriber.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsSubscriber_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueDiscardsPurge
 * rhm010QueueDiscardsPurge is subid 35 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.35
 * Description:
Messages discarded due to management purge
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueDiscardsPurge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueDiscardsPurge_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueDiscardsPurge_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                             U64 * rhm010QueueDiscardsPurge_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueDiscardsPurge_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueDiscardsPurge data.
     * get (* rhm010QueueDiscardsPurge_val_ptr ).low and (* rhm010QueueDiscardsPurge_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueDiscardsPurge_val_ptr).high =
        rowreq_ctx->data.rhm010QueueDiscardsPurge.high;
    (*rhm010QueueDiscardsPurge_val_ptr).low =
        rowreq_ctx->data.rhm010QueueDiscardsPurge.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueDiscardsPurge_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueReroutes
 * rhm010QueueReroutes is subid 36 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.36
 * Description:
Messages dequeued to management re-route
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the rhm010QueueReroutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueReroutes_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueReroutes_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * rhm010QueueReroutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueReroutes_val_ptr);

    /*
     * TODO:231:o: |-> copy rhm010QueueReroutes data.
     * get (* rhm010QueueReroutes_val_ptr ).low and (* rhm010QueueReroutes_val_ptr ).high from rowreq_ctx->data
     */
    (*rhm010QueueReroutes_val_ptr).high =
        rowreq_ctx->data.rhm010QueueReroutes.high;
    (*rhm010QueueReroutes_val_ptr).low =
        rowreq_ctx->data.rhm010QueueReroutes.low;


    return MFD_SUCCESS;
}                               /* rhm010QueueReroutes_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueConsumerCount
 * rhm010QueueConsumerCount is subid 37 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.37
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueConsumerCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueConsumerCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueConsumerCount_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                             long *rhm010QueueConsumerCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueConsumerCount_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueConsumerCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueConsumerCount data.
     * copy (* rhm010QueueConsumerCount_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueConsumerCount_val_ptr) =
        rowreq_ctx->data.rhm010QueueConsumerCount;

    return MFD_SUCCESS;
}                               /* rhm010QueueConsumerCount_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueConsumerCountHi
 * rhm010QueueConsumerCountHi is subid 38 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.38
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueConsumerCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueConsumerCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueConsumerCountHi_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *rhm010QueueConsumerCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueConsumerCountHi_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueConsumerCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueConsumerCountHi data.
     * copy (* rhm010QueueConsumerCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueConsumerCountHi_val_ptr) =
        rowreq_ctx->data.rhm010QueueConsumerCountHi;

    return MFD_SUCCESS;
}                               /* rhm010QueueConsumerCountHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueConsumerCountLow
 * rhm010QueueConsumerCountLow is subid 39 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.39
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueConsumerCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueConsumerCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueConsumerCountLow_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                long *rhm010QueueConsumerCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueConsumerCountLow_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueConsumerCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueConsumerCountLow data.
     * copy (* rhm010QueueConsumerCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueConsumerCountLow_val_ptr) =
        rowreq_ctx->data.rhm010QueueConsumerCountLow;

    return MFD_SUCCESS;
}                               /* rhm010QueueConsumerCountLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueBindingCount
 * rhm010QueueBindingCount is subid 40 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.40
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueBindingCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueBindingCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueBindingCount_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                            long *rhm010QueueBindingCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueBindingCount_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueBindingCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueBindingCount data.
     * copy (* rhm010QueueBindingCount_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueBindingCount_val_ptr) =
        rowreq_ctx->data.rhm010QueueBindingCount;

    return MFD_SUCCESS;
}                               /* rhm010QueueBindingCount_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueBindingCountHi
 * rhm010QueueBindingCountHi is subid 41 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.41
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueBindingCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueBindingCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueBindingCountHi_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              long *rhm010QueueBindingCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueBindingCountHi_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueBindingCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueBindingCountHi data.
     * copy (* rhm010QueueBindingCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueBindingCountHi_val_ptr) =
        rowreq_ctx->data.rhm010QueueBindingCountHi;

    return MFD_SUCCESS;
}                               /* rhm010QueueBindingCountHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueBindingCountLow
 * rhm010QueueBindingCountLow is subid 42 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.42
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueBindingCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueBindingCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueBindingCountLow_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *rhm010QueueBindingCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueBindingCountLow_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueBindingCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueBindingCountLow data.
     * copy (* rhm010QueueBindingCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueBindingCountLow_val_ptr) =
        rowreq_ctx->data.rhm010QueueBindingCountLow;

    return MFD_SUCCESS;
}                               /* rhm010QueueBindingCountLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueUnackedMessages
 * rhm010QueueUnackedMessages is subid 43 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.43
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueUnackedMessages data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueUnackedMessages_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueUnackedMessages_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *rhm010QueueUnackedMessages_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueUnackedMessages_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueUnackedMessages_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueUnackedMessages data.
     * copy (* rhm010QueueUnackedMessages_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueUnackedMessages_val_ptr) =
        rowreq_ctx->data.rhm010QueueUnackedMessages;

    return MFD_SUCCESS;
}                               /* rhm010QueueUnackedMessages_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueUnackedMessagesHi
 * rhm010QueueUnackedMessagesHi is subid 44 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.44
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueUnackedMessagesHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueUnackedMessagesHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueUnackedMessagesHi_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                 long
                                 *rhm010QueueUnackedMessagesHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueUnackedMessagesHi_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueUnackedMessagesHi_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueUnackedMessagesHi data.
     * copy (* rhm010QueueUnackedMessagesHi_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueUnackedMessagesHi_val_ptr) =
        rowreq_ctx->data.rhm010QueueUnackedMessagesHi;

    return MFD_SUCCESS;
}                               /* rhm010QueueUnackedMessagesHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueUnackedMessagesLow
 * rhm010QueueUnackedMessagesLow is subid 45 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.45
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the rhm010QueueUnackedMessagesLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueUnackedMessagesLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueUnackedMessagesLow_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                  long
                                  *rhm010QueueUnackedMessagesLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueUnackedMessagesLow_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueUnackedMessagesLow_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueUnackedMessagesLow data.
     * copy (* rhm010QueueUnackedMessagesLow_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueUnackedMessagesLow_val_ptr) =
        rowreq_ctx->data.rhm010QueueUnackedMessagesLow;

    return MFD_SUCCESS;
}                               /* rhm010QueueUnackedMessagesLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueMessageLatency
 * rhm010QueueMessageLatency is subid 46 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.46
 * Description:
Broker latency through this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueMessageLatency data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueMessageLatency_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueMessageLatency_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                              u_long * rhm010QueueMessageLatency_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueMessageLatency_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueMessageLatency_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueMessageLatency data.
     * copy (* rhm010QueueMessageLatency_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueMessageLatency_val_ptr) =
        rowreq_ctx->data.rhm010QueueMessageLatency;

    return MFD_SUCCESS;
}                               /* rhm010QueueMessageLatency_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueFlowStopped
 * rhm010QueueFlowStopped is subid 47 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.47
 * Description:
Flow control active.
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueFlowStopped data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueFlowStopped_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueFlowStopped_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                           u_long * rhm010QueueFlowStopped_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueFlowStopped_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueFlowStopped_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueFlowStopped data.
     * copy (* rhm010QueueFlowStopped_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueFlowStopped_val_ptr) =
        rowreq_ctx->data.rhm010QueueFlowStopped;

    return MFD_SUCCESS;
}                               /* rhm010QueueFlowStopped_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::rhm010QueueEntry.rhm010QueueFlowStoppedCount
 * rhm010QueueFlowStoppedCount is subid 48 of rhm010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2312.5672.1.1.6.1.1.48
 * Description:
Number of times flow control was activated for this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rhm010QueueFlowStoppedCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rhm010QueueFlowStoppedCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rhm010QueueFlowStoppedCount_get(rhm010QueueTable_rowreq_ctx * rowreq_ctx,
                                u_long *
                                rhm010QueueFlowStoppedCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rhm010QueueFlowStoppedCount_val_ptr);


    DEBUGMSGTL(("verbose:rhm010QueueTable:rhm010QueueFlowStoppedCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rhm010QueueFlowStoppedCount data.
     * copy (* rhm010QueueFlowStoppedCount_val_ptr ) from rowreq_ctx->data
     */
    (*rhm010QueueFlowStoppedCount_val_ptr) =
        rowreq_ctx->data.rhm010QueueFlowStoppedCount;

    return MFD_SUCCESS;
}                               /* rhm010QueueFlowStoppedCount_get */



/** @} */
