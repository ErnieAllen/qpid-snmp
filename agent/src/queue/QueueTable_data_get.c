/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "QueueTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement qpid010QueueTable get routines.
 * TODO:240:M: Implement qpid010QueueTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table qpid010QueueTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * MRG-MESSAGING-MIB::qpid010QueueTable is subid 1 of qpid010Queues.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement qpid010QueueTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param qpid010QueueInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
qpid010QueueTable_indexes_set_tbl_idx(qpid010QueueTable_mib_index * tbl_idx,
                                     u_long qpid010QueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueTable_indexes_set_tbl_idx", "called\n"));

    /*
     * qpid010QueueInternalIndex(49)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->qpid010QueueInternalIndex = qpid010QueueInternalIndex_val;


    return MFD_SUCCESS;
}                               /* qpid010QueueTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
qpid010QueueTable_indexes_set(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                             u_long qpid010QueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        qpid010QueueTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                             qpid010QueueInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != qpid010QueueTable_index_to_oid(&rowreq_ctx->oid_idx,
                                           &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* qpid010QueueTable_indexes_set */


/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueVhostRef
 * qpid010QueueVhostRef is subid 1 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.1
 * Description:
Queue vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010QueueVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010QueueVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010QueueVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010QueueVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010QueueVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010QueueVhostRef_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                        char **qpid010QueueVhostRef_val_ptr_ptr,
                        size_t *qpid010QueueVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010QueueVhostRef_val_ptr_ptr)
                   && (NULL != *qpid010QueueVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010QueueVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueVhostRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueVhostRef data.
     * copy (* qpid010QueueVhostRef_val_ptr_ptr ) data and (* qpid010QueueVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010QueueVhostRef data
     */
    if ((NULL == (*qpid010QueueVhostRef_val_ptr_ptr)) ||
        ((*qpid010QueueVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010QueueVhostRef_len *
          sizeof(rowreq_ctx->data.qpid010QueueVhostRef[0])))) {
        /*
         * allocate space for qpid010QueueVhostRef data
         */
        (*qpid010QueueVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010QueueVhostRef_len *
                   sizeof(rowreq_ctx->data.qpid010QueueVhostRef[0]));
        if (NULL == (*qpid010QueueVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010QueueVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010QueueVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010QueueVhostRef_len *
        sizeof(rowreq_ctx->data.qpid010QueueVhostRef[0]);
    memcpy((*qpid010QueueVhostRef_val_ptr_ptr),
           rowreq_ctx->data.qpid010QueueVhostRef,
           rowreq_ctx->data.qpid010QueueVhostRef_len *
           sizeof(rowreq_ctx->data.qpid010QueueVhostRef[0]));

    return MFD_SUCCESS;
}                               /* qpid010QueueVhostRef_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueName
 * qpid010QueueName is subid 2 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.2
 * Description:
Queue name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010QueueName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010QueueName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010QueueName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010QueueName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010QueueName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010QueueName_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                    char **qpid010QueueName_val_ptr_ptr,
                    size_t *qpid010QueueName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010QueueName_val_ptr_ptr)
                   && (NULL != *qpid010QueueName_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010QueueName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueName data.
     * copy (* qpid010QueueName_val_ptr_ptr ) data and (* qpid010QueueName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010QueueName data
     */
    if ((NULL == (*qpid010QueueName_val_ptr_ptr)) ||
        ((*qpid010QueueName_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010QueueName_len *
          sizeof(rowreq_ctx->data.qpid010QueueName[0])))) {
        /*
         * allocate space for qpid010QueueName data
         */
        (*qpid010QueueName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010QueueName_len *
                   sizeof(rowreq_ctx->data.qpid010QueueName[0]));
        if (NULL == (*qpid010QueueName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010QueueName)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010QueueName_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010QueueName_len *
        sizeof(rowreq_ctx->data.qpid010QueueName[0]);
    memcpy((*qpid010QueueName_val_ptr_ptr),
           rowreq_ctx->data.qpid010QueueName,
           rowreq_ctx->data.qpid010QueueName_len *
           sizeof(rowreq_ctx->data.qpid010QueueName[0]));

    return MFD_SUCCESS;
}                               /* qpid010QueueName_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDurable
 * qpid010QueueDurable is subid 3 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.3
 * Description:
Queue durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDurable_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                       u_long * qpid010QueueDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDurable_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueDurable data.
     * copy (* qpid010QueueDurable_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueDurable_val_ptr) = rowreq_ctx->data.qpid010QueueDurable;

    return MFD_SUCCESS;
}                               /* qpid010QueueDurable_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueAutoDelete
 * qpid010QueueAutoDelete is subid 4 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.4
 * Description:
Queue autoDelete
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueAutoDelete data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueAutoDelete_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueAutoDelete_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                          u_long * qpid010QueueAutoDelete_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueAutoDelete_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueAutoDelete_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueAutoDelete data.
     * copy (* qpid010QueueAutoDelete_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueAutoDelete_val_ptr) =
        rowreq_ctx->data.qpid010QueueAutoDelete;

    return MFD_SUCCESS;
}                               /* qpid010QueueAutoDelete_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueExclusive
 * qpid010QueueExclusive is subid 5 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.5
 * Description:
Queue exclusive
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueExclusive data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueExclusive_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueExclusive_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                         u_long * qpid010QueueExclusive_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueExclusive_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueExclusive_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueExclusive data.
     * copy (* qpid010QueueExclusive_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueExclusive_val_ptr) =
        rowreq_ctx->data.qpid010QueueExclusive;

    return MFD_SUCCESS;
}                               /* qpid010QueueExclusive_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueArguments
 * qpid010QueueArguments is subid 6 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.6
 * Description:
Arguments supplied in queue.declare
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Map (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the qpid010QueueArguments data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueArguments_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010QueueArguments_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010QueueArguments.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010QueueArguments_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010QueueArguments_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010QueueArguments_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                         char **qpid010QueueArguments_val_ptr_ptr,
                         size_t *qpid010QueueArguments_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010QueueArguments_val_ptr_ptr)
                   && (NULL != *qpid010QueueArguments_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010QueueArguments_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueArguments_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueArguments data.
     * copy (* qpid010QueueArguments_val_ptr_ptr ) data and (* qpid010QueueArguments_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010QueueArguments data
     */
    if ((NULL == (*qpid010QueueArguments_val_ptr_ptr)) ||
        ((*qpid010QueueArguments_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010QueueArguments_len *
          sizeof(rowreq_ctx->data.qpid010QueueArguments[0])))) {
        /*
         * allocate space for qpid010QueueArguments data
         */
        (*qpid010QueueArguments_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010QueueArguments_len *
                   sizeof(rowreq_ctx->data.qpid010QueueArguments[0]));
        if (NULL == (*qpid010QueueArguments_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010QueueArguments)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010QueueArguments_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010QueueArguments_len *
        sizeof(rowreq_ctx->data.qpid010QueueArguments[0]);
    memcpy((*qpid010QueueArguments_val_ptr_ptr),
           rowreq_ctx->data.qpid010QueueArguments,
           rowreq_ctx->data.qpid010QueueArguments_len *
           sizeof(rowreq_ctx->data.qpid010QueueArguments[0]));

    return MFD_SUCCESS;
}                               /* qpid010QueueArguments_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueAltExchange
 * qpid010QueueAltExchange is subid 7 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.7
 * Description:
Queue altExchange
                     Additional info ( nodeType:property, references:Exchange, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the qpid010QueueAltExchange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueAltExchange_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param qpid010QueueAltExchange_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by qpid010QueueAltExchange.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*qpid010QueueAltExchange_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update qpid010QueueAltExchange_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
qpid010QueueAltExchange_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                           char **qpid010QueueAltExchange_val_ptr_ptr,
                           size_t *qpid010QueueAltExchange_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != qpid010QueueAltExchange_val_ptr_ptr)
                   && (NULL != *qpid010QueueAltExchange_val_ptr_ptr));
    netsnmp_assert(NULL != qpid010QueueAltExchange_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueAltExchange_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueAltExchange data.
     * copy (* qpid010QueueAltExchange_val_ptr_ptr ) data and (* qpid010QueueAltExchange_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for qpid010QueueAltExchange data
     */
    if ((NULL == (*qpid010QueueAltExchange_val_ptr_ptr)) ||
        ((*qpid010QueueAltExchange_val_ptr_len_ptr) <
         (rowreq_ctx->data.qpid010QueueAltExchange_len *
          sizeof(rowreq_ctx->data.qpid010QueueAltExchange[0])))) {
        /*
         * allocate space for qpid010QueueAltExchange data
         */
        (*qpid010QueueAltExchange_val_ptr_ptr) =
            malloc(rowreq_ctx->data.qpid010QueueAltExchange_len *
                   sizeof(rowreq_ctx->data.qpid010QueueAltExchange[0]));
        if (NULL == (*qpid010QueueAltExchange_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.qpid010QueueAltExchange)\n");
            return MFD_ERROR;
        }
    }
    (*qpid010QueueAltExchange_val_ptr_len_ptr) =
        rowreq_ctx->data.qpid010QueueAltExchange_len *
        sizeof(rowreq_ctx->data.qpid010QueueAltExchange[0]);
    memcpy((*qpid010QueueAltExchange_val_ptr_ptr),
           rowreq_ctx->data.qpid010QueueAltExchange,
           rowreq_ctx->data.qpid010QueueAltExchange_len *
           sizeof(rowreq_ctx->data.qpid010QueueAltExchange[0]));

    return MFD_SUCCESS;
}                               /* qpid010QueueAltExchange_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgTotalEnqueues
 * qpid010QueueMsgTotalEnqueues is subid 8 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.8
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgTotalEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * qpid010QueueMsgTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgTotalEnqueues data.
     * get (* qpid010QueueMsgTotalEnqueues_val_ptr ).low and (* qpid010QueueMsgTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgTotalEnqueues.high;
    (*qpid010QueueMsgTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgTotalEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgTotalDequeues
 * qpid010QueueMsgTotalDequeues is subid 9 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.9
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgTotalDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * qpid010QueueMsgTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgTotalDequeues data.
     * get (* qpid010QueueMsgTotalDequeues_val_ptr ).low and (* qpid010QueueMsgTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgTotalDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgTotalDequeues.high;
    (*qpid010QueueMsgTotalDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgTotalDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgTxnEnqueues
 * qpid010QueueMsgTxnEnqueues is subid 10 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.10
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgTxnEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * qpid010QueueMsgTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgTxnEnqueues data.
     * get (* qpid010QueueMsgTxnEnqueues_val_ptr ).low and (* qpid010QueueMsgTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgTxnEnqueues.high;
    (*qpid010QueueMsgTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgTxnEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgTxnDequeues
 * qpid010QueueMsgTxnDequeues is subid 11 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.11
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgTxnDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * qpid010QueueMsgTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgTxnDequeues data.
     * get (* qpid010QueueMsgTxnDequeues_val_ptr ).low and (* qpid010QueueMsgTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgTxnDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgTxnDequeues.high;
    (*qpid010QueueMsgTxnDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgTxnDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgPersistEnqueues
 * qpid010QueueMsgPersistEnqueues is subid 12 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.12
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgPersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgPersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgPersistEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  qpid010QueueMsgPersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgPersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgPersistEnqueues data.
     * get (* qpid010QueueMsgPersistEnqueues_val_ptr ).low and (* qpid010QueueMsgPersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgPersistEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgPersistEnqueues.high;
    (*qpid010QueueMsgPersistEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgPersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgPersistEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgPersistDequeues
 * qpid010QueueMsgPersistDequeues is subid 13 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.13
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgPersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgPersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgPersistDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  qpid010QueueMsgPersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgPersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgPersistDequeues data.
     * get (* qpid010QueueMsgPersistDequeues_val_ptr ).low and (* qpid010QueueMsgPersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgPersistDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgPersistDequeues.high;
    (*qpid010QueueMsgPersistDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgPersistDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgPersistDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgDepth
 * qpid010QueueMsgDepth is subid 14 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.14
 * Description:
Current size of queue in messages
                     Additional info ( nodeType:statistic, assign:msgTotalEnqueues - msgTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgDepth_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * qpid010QueueMsgDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgDepth data.
     * get (* qpid010QueueMsgDepth_val_ptr ).low and (* qpid010QueueMsgDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgDepth_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgDepth.high;
    (*qpid010QueueMsgDepth_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgDepth.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteDepth
 * qpid010QueueByteDepth is subid 15 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.15
 * Description:
Current size of queue in bytes
                     Additional info ( nodeType:statistic, assign:byteTotalEnqueues - byteTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteDepth_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                         U64 * qpid010QueueByteDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteDepth data.
     * get (* qpid010QueueByteDepth_val_ptr ).low and (* qpid010QueueByteDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteDepth_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteDepth.high;
    (*qpid010QueueByteDepth_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteDepth.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteTotalEnqueues
 * qpid010QueueByteTotalEnqueues is subid 16 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.16
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteTotalEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 qpid010QueueByteTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteTotalEnqueues data.
     * get (* qpid010QueueByteTotalEnqueues_val_ptr ).low and (* qpid010QueueByteTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteTotalEnqueues.high;
    (*qpid010QueueByteTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteTotalEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteTotalDequeues
 * qpid010QueueByteTotalDequeues is subid 17 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.17
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteTotalDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 qpid010QueueByteTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteTotalDequeues data.
     * get (* qpid010QueueByteTotalDequeues_val_ptr ).low and (* qpid010QueueByteTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteTotalDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteTotalDequeues.high;
    (*qpid010QueueByteTotalDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteTotalDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteTxnEnqueues
 * qpid010QueueByteTxnEnqueues is subid 18 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.18
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteTxnEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * qpid010QueueByteTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteTxnEnqueues data.
     * get (* qpid010QueueByteTxnEnqueues_val_ptr ).low and (* qpid010QueueByteTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteTxnEnqueues.high;
    (*qpid010QueueByteTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteTxnEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteTxnDequeues
 * qpid010QueueByteTxnDequeues is subid 19 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.19
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteTxnDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * qpid010QueueByteTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteTxnDequeues data.
     * get (* qpid010QueueByteTxnDequeues_val_ptr ).low and (* qpid010QueueByteTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteTxnDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteTxnDequeues.high;
    (*qpid010QueueByteTxnDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteTxnDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueBytePersistEnqueues
 * qpid010QueueBytePersistEnqueues is subid 20 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.20
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueBytePersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueBytePersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueBytePersistEnqueues_get(qpid010QueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   qpid010QueueBytePersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueBytePersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueBytePersistEnqueues data.
     * get (* qpid010QueueBytePersistEnqueues_val_ptr ).low and (* qpid010QueueBytePersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueBytePersistEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueBytePersistEnqueues.high;
    (*qpid010QueueBytePersistEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueBytePersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueBytePersistEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueBytePersistDequeues
 * qpid010QueueBytePersistDequeues is subid 21 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.21
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueBytePersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueBytePersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueBytePersistDequeues_get(qpid010QueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   qpid010QueueBytePersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueBytePersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueBytePersistDequeues data.
     * get (* qpid010QueueBytePersistDequeues_val_ptr ).low and (* qpid010QueueBytePersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueBytePersistDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueBytePersistDequeues.high;
    (*qpid010QueueBytePersistDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueBytePersistDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueBytePersistDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgFtdEnqueues
 * qpid010QueueMsgFtdEnqueues is subid 22 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.22
 * Description:
Total message bodies released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgFtdEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * qpid010QueueMsgFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgFtdEnqueues data.
     * get (* qpid010QueueMsgFtdEnqueues_val_ptr ).low and (* qpid010QueueMsgFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgFtdEnqueues.high;
    (*qpid010QueueMsgFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgFtdEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgFtdDequeues
 * qpid010QueueMsgFtdDequeues is subid 23 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.23
 * Description:
Total message bodies dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgFtdDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * qpid010QueueMsgFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgFtdDequeues data.
     * get (* qpid010QueueMsgFtdDequeues_val_ptr ).low and (* qpid010QueueMsgFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgFtdDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgFtdDequeues.high;
    (*qpid010QueueMsgFtdDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgFtdDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteFtdEnqueues
 * qpid010QueueByteFtdEnqueues is subid 24 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.24
 * Description:
Total bytes released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteFtdEnqueues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * qpid010QueueByteFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteFtdEnqueues data.
     * get (* qpid010QueueByteFtdEnqueues_val_ptr ).low and (* qpid010QueueByteFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteFtdEnqueues.high;
    (*qpid010QueueByteFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteFtdEnqueues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteFtdDequeues
 * qpid010QueueByteFtdDequeues is subid 25 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.25
 * Description:
Total bytes dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteFtdDequeues_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * qpid010QueueByteFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteFtdDequeues data.
     * get (* qpid010QueueByteFtdDequeues_val_ptr ).low and (* qpid010QueueByteFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteFtdDequeues_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteFtdDequeues.high;
    (*qpid010QueueByteFtdDequeues_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteFtdDequeues_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMsgFtdDepth
 * qpid010QueueMsgFtdDepth is subid 26 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.26
 * Description:
Current number of messages flowed-to-disk
                     Additional info ( nodeType:statistic, assign:msgFtdEnqueues - msgFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueMsgFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMsgFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMsgFtdDepth_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * qpid010QueueMsgFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMsgFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueMsgFtdDepth data.
     * get (* qpid010QueueMsgFtdDepth_val_ptr ).low and (* qpid010QueueMsgFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueMsgFtdDepth_val_ptr).high =
        rowreq_ctx->data.qpid010QueueMsgFtdDepth.high;
    (*qpid010QueueMsgFtdDepth_val_ptr).low =
        rowreq_ctx->data.qpid010QueueMsgFtdDepth.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueMsgFtdDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueByteFtdDepth
 * qpid010QueueByteFtdDepth is subid 27 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.27
 * Description:
Current number of bytes flowed-to-disk
                     Additional info ( nodeType:statistic, assign:byteFtdEnqueues - byteFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueByteFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueByteFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueByteFtdDepth_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * qpid010QueueByteFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueByteFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueByteFtdDepth data.
     * get (* qpid010QueueByteFtdDepth_val_ptr ).low and (* qpid010QueueByteFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueByteFtdDepth_val_ptr).high =
        rowreq_ctx->data.qpid010QueueByteFtdDepth.high;
    (*qpid010QueueByteFtdDepth_val_ptr).low =
        rowreq_ctx->data.qpid010QueueByteFtdDepth.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueByteFtdDepth_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueReleases
 * qpid010QueueReleases is subid 28 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.28
 * Description:
Acquired messages reinserted into the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueReleases data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueReleases_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueReleases_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * qpid010QueueReleases_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueReleases_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueReleases data.
     * get (* qpid010QueueReleases_val_ptr ).low and (* qpid010QueueReleases_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueReleases_val_ptr).high =
        rowreq_ctx->data.qpid010QueueReleases.high;
    (*qpid010QueueReleases_val_ptr).low =
        rowreq_ctx->data.qpid010QueueReleases.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueReleases_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueAcquires
 * qpid010QueueAcquires is subid 29 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.29
 * Description:
Messages acquired from the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueAcquires data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueAcquires_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueAcquires_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * qpid010QueueAcquires_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueAcquires_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueAcquires data.
     * get (* qpid010QueueAcquires_val_ptr ).low and (* qpid010QueueAcquires_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueAcquires_val_ptr).high =
        rowreq_ctx->data.qpid010QueueAcquires.high;
    (*qpid010QueueAcquires_val_ptr).low =
        rowreq_ctx->data.qpid010QueueAcquires.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueAcquires_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsTtl
 * qpid010QueueDiscardsTtl is subid 30 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.30
 * Description:
Messages discarded due to TTL expiration
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsTtl data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsTtl_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsTtl_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * qpid010QueueDiscardsTtl_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsTtl_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsTtl data.
     * get (* qpid010QueueDiscardsTtl_val_ptr ).low and (* qpid010QueueDiscardsTtl_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsTtl_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsTtl.high;
    (*qpid010QueueDiscardsTtl_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsTtl.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsTtl_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsRing
 * qpid010QueueDiscardsRing is subid 31 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.31
 * Description:
Messages discarded due to ring-queue overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsRing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsRing_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsRing_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * qpid010QueueDiscardsRing_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsRing_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsRing data.
     * get (* qpid010QueueDiscardsRing_val_ptr ).low and (* qpid010QueueDiscardsRing_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsRing_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsRing.high;
    (*qpid010QueueDiscardsRing_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsRing.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsRing_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsLvq
 * qpid010QueueDiscardsLvq is subid 32 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.32
 * Description:
Messages discarded due to LVQ insert
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsLvq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsLvq_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsLvq_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * qpid010QueueDiscardsLvq_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsLvq_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsLvq data.
     * get (* qpid010QueueDiscardsLvq_val_ptr ).low and (* qpid010QueueDiscardsLvq_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsLvq_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsLvq.high;
    (*qpid010QueueDiscardsLvq_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsLvq.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsLvq_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsOverflow
 * qpid010QueueDiscardsOverflow is subid 33 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.33
 * Description:
Messages discarded due to reject-policy overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsOverflow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsOverflow_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsOverflow_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * qpid010QueueDiscardsOverflow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsOverflow_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsOverflow data.
     * get (* qpid010QueueDiscardsOverflow_val_ptr ).low and (* qpid010QueueDiscardsOverflow_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsOverflow_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsOverflow.high;
    (*qpid010QueueDiscardsOverflow_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsOverflow.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsOverflow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsSubscriber
 * qpid010QueueDiscardsSubscriber is subid 34 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.34
 * Description:
Messages discarded due to subscriber reject
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsSubscriber data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsSubscriber_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsSubscriber_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  qpid010QueueDiscardsSubscriber_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsSubscriber_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsSubscriber data.
     * get (* qpid010QueueDiscardsSubscriber_val_ptr ).low and (* qpid010QueueDiscardsSubscriber_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsSubscriber_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsSubscriber.high;
    (*qpid010QueueDiscardsSubscriber_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsSubscriber.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsSubscriber_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueDiscardsPurge
 * qpid010QueueDiscardsPurge is subid 35 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.35
 * Description:
Messages discarded due to management purge
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueDiscardsPurge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueDiscardsPurge_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueDiscardsPurge_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                             U64 * qpid010QueueDiscardsPurge_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueDiscardsPurge_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueDiscardsPurge data.
     * get (* qpid010QueueDiscardsPurge_val_ptr ).low and (* qpid010QueueDiscardsPurge_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueDiscardsPurge_val_ptr).high =
        rowreq_ctx->data.qpid010QueueDiscardsPurge.high;
    (*qpid010QueueDiscardsPurge_val_ptr).low =
        rowreq_ctx->data.qpid010QueueDiscardsPurge.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueDiscardsPurge_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueReroutes
 * qpid010QueueReroutes is subid 36 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.36
 * Description:
Messages dequeued to management re-route
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the qpid010QueueReroutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueReroutes_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueReroutes_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * qpid010QueueReroutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueReroutes_val_ptr);

    /*
     * TODO:231:o: |-> copy qpid010QueueReroutes data.
     * get (* qpid010QueueReroutes_val_ptr ).low and (* qpid010QueueReroutes_val_ptr ).high from rowreq_ctx->data
     */
    (*qpid010QueueReroutes_val_ptr).high =
        rowreq_ctx->data.qpid010QueueReroutes.high;
    (*qpid010QueueReroutes_val_ptr).low =
        rowreq_ctx->data.qpid010QueueReroutes.low;


    return MFD_SUCCESS;
}                               /* qpid010QueueReroutes_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueConsumerCount
 * qpid010QueueConsumerCount is subid 37 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.37
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueConsumerCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueConsumerCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueConsumerCount_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                             long *qpid010QueueConsumerCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueConsumerCount_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueConsumerCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueConsumerCount data.
     * copy (* qpid010QueueConsumerCount_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueConsumerCount_val_ptr) =
        rowreq_ctx->data.qpid010QueueConsumerCount;

    return MFD_SUCCESS;
}                               /* qpid010QueueConsumerCount_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueConsumerCountHi
 * qpid010QueueConsumerCountHi is subid 38 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.38
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueConsumerCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueConsumerCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueConsumerCountHi_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *qpid010QueueConsumerCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueConsumerCountHi_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueConsumerCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueConsumerCountHi data.
     * copy (* qpid010QueueConsumerCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueConsumerCountHi_val_ptr) =
        rowreq_ctx->data.qpid010QueueConsumerCountHi;

    return MFD_SUCCESS;
}                               /* qpid010QueueConsumerCountHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueConsumerCountLow
 * qpid010QueueConsumerCountLow is subid 39 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.39
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueConsumerCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueConsumerCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueConsumerCountLow_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                long *qpid010QueueConsumerCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueConsumerCountLow_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueConsumerCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueConsumerCountLow data.
     * copy (* qpid010QueueConsumerCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueConsumerCountLow_val_ptr) =
        rowreq_ctx->data.qpid010QueueConsumerCountLow;

    return MFD_SUCCESS;
}                               /* qpid010QueueConsumerCountLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueBindingCount
 * qpid010QueueBindingCount is subid 40 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.40
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueBindingCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueBindingCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueBindingCount_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                            long *qpid010QueueBindingCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueBindingCount_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueBindingCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueBindingCount data.
     * copy (* qpid010QueueBindingCount_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueBindingCount_val_ptr) =
        rowreq_ctx->data.qpid010QueueBindingCount;

    return MFD_SUCCESS;
}                               /* qpid010QueueBindingCount_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueBindingCountHi
 * qpid010QueueBindingCountHi is subid 41 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.41
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueBindingCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueBindingCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueBindingCountHi_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              long *qpid010QueueBindingCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueBindingCountHi_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueBindingCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueBindingCountHi data.
     * copy (* qpid010QueueBindingCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueBindingCountHi_val_ptr) =
        rowreq_ctx->data.qpid010QueueBindingCountHi;

    return MFD_SUCCESS;
}                               /* qpid010QueueBindingCountHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueBindingCountLow
 * qpid010QueueBindingCountLow is subid 42 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.42
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueBindingCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueBindingCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueBindingCountLow_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *qpid010QueueBindingCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueBindingCountLow_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueBindingCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueBindingCountLow data.
     * copy (* qpid010QueueBindingCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueBindingCountLow_val_ptr) =
        rowreq_ctx->data.qpid010QueueBindingCountLow;

    return MFD_SUCCESS;
}                               /* qpid010QueueBindingCountLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueUnackedMessages
 * qpid010QueueUnackedMessages is subid 43 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.43
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueUnackedMessages data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueUnackedMessages_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueUnackedMessages_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                               long *qpid010QueueUnackedMessages_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueUnackedMessages_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueUnackedMessages_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueUnackedMessages data.
     * copy (* qpid010QueueUnackedMessages_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueUnackedMessages_val_ptr) =
        rowreq_ctx->data.qpid010QueueUnackedMessages;

    return MFD_SUCCESS;
}                               /* qpid010QueueUnackedMessages_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueUnackedMessagesHi
 * qpid010QueueUnackedMessagesHi is subid 44 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.44
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueUnackedMessagesHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueUnackedMessagesHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueUnackedMessagesHi_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                 long
                                 *qpid010QueueUnackedMessagesHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueUnackedMessagesHi_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueUnackedMessagesHi_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueUnackedMessagesHi data.
     * copy (* qpid010QueueUnackedMessagesHi_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueUnackedMessagesHi_val_ptr) =
        rowreq_ctx->data.qpid010QueueUnackedMessagesHi;

    return MFD_SUCCESS;
}                               /* qpid010QueueUnackedMessagesHi_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueUnackedMessagesLow
 * qpid010QueueUnackedMessagesLow is subid 45 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.45
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the qpid010QueueUnackedMessagesLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueUnackedMessagesLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueUnackedMessagesLow_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                  long
                                  *qpid010QueueUnackedMessagesLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueUnackedMessagesLow_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueUnackedMessagesLow_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueUnackedMessagesLow data.
     * copy (* qpid010QueueUnackedMessagesLow_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueUnackedMessagesLow_val_ptr) =
        rowreq_ctx->data.qpid010QueueUnackedMessagesLow;

    return MFD_SUCCESS;
}                               /* qpid010QueueUnackedMessagesLow_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueMessageLatency
 * qpid010QueueMessageLatency is subid 46 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.46
 * Description:
Broker latency through this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueMessageLatency data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueMessageLatency_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueMessageLatency_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                              u_long * qpid010QueueMessageLatency_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueMessageLatency_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueMessageLatency_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueMessageLatency data.
     * copy (* qpid010QueueMessageLatency_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueMessageLatency_val_ptr) =
        rowreq_ctx->data.qpid010QueueMessageLatency;

    return MFD_SUCCESS;
}                               /* qpid010QueueMessageLatency_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueFlowStopped
 * qpid010QueueFlowStopped is subid 47 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.47
 * Description:
Flow control active.
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueFlowStopped data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueFlowStopped_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueFlowStopped_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                           u_long * qpid010QueueFlowStopped_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueFlowStopped_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueFlowStopped_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueFlowStopped data.
     * copy (* qpid010QueueFlowStopped_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueFlowStopped_val_ptr) =
        rowreq_ctx->data.qpid010QueueFlowStopped;

    return MFD_SUCCESS;
}                               /* qpid010QueueFlowStopped_get */

/*---------------------------------------------------------------------
 * MRG-MESSAGING-MIB::qpid010QueueEntry.qpid010QueueFlowStoppedCount
 * qpid010QueueFlowStoppedCount is subid 48 of qpid010QueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.48
 * Description:
Number of times flow control was activated for this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the qpid010QueueFlowStoppedCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param qpid010QueueFlowStoppedCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
qpid010QueueFlowStoppedCount_get(qpid010QueueTable_rowreq_ctx * rowreq_ctx,
                                u_long *
                                qpid010QueueFlowStoppedCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != qpid010QueueFlowStoppedCount_val_ptr);


    DEBUGMSGTL(("verbose:qpid010QueueTable:qpid010QueueFlowStoppedCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the qpid010QueueFlowStoppedCount data.
     * copy (* qpid010QueueFlowStoppedCount_val_ptr ) from rowreq_ctx->data
     */
    (*qpid010QueueFlowStoppedCount_val_ptr) =
        rowreq_ctx->data.qpid010QueueFlowStoppedCount;

    return MFD_SUCCESS;
}                               /* qpid010QueueFlowStoppedCount_get */



/** @} */
