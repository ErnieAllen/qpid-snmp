/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include "../include/net-snmp-features.h"
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "QueueTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement brokerQueueTable get routines.
 * TODO:240:M: Implement brokerQueueTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table brokerQueueTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * QPID-MESSAGING-MIB::brokerQueueTable is subid 1 of brokerQueues.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement brokerQueueTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param brokerQueueInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
brokerQueueTable_indexes_set_tbl_idx(brokerQueueTable_mib_index * tbl_idx,
                                     u_long brokerQueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueTable_indexes_set_tbl_idx", "called\n"));

    /*
     * brokerQueueInternalIndex(49)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->brokerQueueInternalIndex = brokerQueueInternalIndex_val;


    return MFD_SUCCESS;
}                               /* brokerQueueTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
brokerQueueTable_indexes_set(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                             u_long brokerQueueInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        brokerQueueTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                             brokerQueueInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != brokerQueueTable_index_to_oid(&rowreq_ctx->oid_idx,
                                           &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* brokerQueueTable_indexes_set */


/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueVhostRef
 * brokerQueueVhostRef is subid 1 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.1
 * Description:
Queue vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerQueueVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerQueueVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerQueueVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerQueueVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerQueueVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerQueueVhostRef_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                        char **brokerQueueVhostRef_val_ptr_ptr,
                        size_t *brokerQueueVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerQueueVhostRef_val_ptr_ptr)
                   && (NULL != *brokerQueueVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != brokerQueueVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueVhostRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueVhostRef data.
     * copy (* brokerQueueVhostRef_val_ptr_ptr ) data and (* brokerQueueVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerQueueVhostRef data
     */
    if ((NULL == (*brokerQueueVhostRef_val_ptr_ptr)) ||
        ((*brokerQueueVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerQueueVhostRef_len *
          sizeof(rowreq_ctx->data.brokerQueueVhostRef[0])))) {
        /*
         * allocate space for brokerQueueVhostRef data
         */
        (*brokerQueueVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerQueueVhostRef_len *
                   sizeof(rowreq_ctx->data.brokerQueueVhostRef[0]));
        if (NULL == (*brokerQueueVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerQueueVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*brokerQueueVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerQueueVhostRef_len *
        sizeof(rowreq_ctx->data.brokerQueueVhostRef[0]);
    memcpy((*brokerQueueVhostRef_val_ptr_ptr),
           rowreq_ctx->data.brokerQueueVhostRef,
           rowreq_ctx->data.brokerQueueVhostRef_len *
           sizeof(rowreq_ctx->data.brokerQueueVhostRef[0]));

    return MFD_SUCCESS;
}                               /* brokerQueueVhostRef_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueName
 * brokerQueueName is subid 2 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.2
 * Description:
Queue name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerQueueName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerQueueName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerQueueName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerQueueName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerQueueName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerQueueName_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                    char **brokerQueueName_val_ptr_ptr,
                    size_t *brokerQueueName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerQueueName_val_ptr_ptr)
                   && (NULL != *brokerQueueName_val_ptr_ptr));
    netsnmp_assert(NULL != brokerQueueName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueName data.
     * copy (* brokerQueueName_val_ptr_ptr ) data and (* brokerQueueName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerQueueName data
     */
    if ((NULL == (*brokerQueueName_val_ptr_ptr)) ||
        ((*brokerQueueName_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerQueueName_len *
          sizeof(rowreq_ctx->data.brokerQueueName[0])))) {
        /*
         * allocate space for brokerQueueName data
         */
        (*brokerQueueName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerQueueName_len *
                   sizeof(rowreq_ctx->data.brokerQueueName[0]));
        if (NULL == (*brokerQueueName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerQueueName)\n");
            return MFD_ERROR;
        }
    }
    (*brokerQueueName_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerQueueName_len *
        sizeof(rowreq_ctx->data.brokerQueueName[0]);
    memcpy((*brokerQueueName_val_ptr_ptr),
           rowreq_ctx->data.brokerQueueName,
           rowreq_ctx->data.brokerQueueName_len *
           sizeof(rowreq_ctx->data.brokerQueueName[0]));

    return MFD_SUCCESS;
}                               /* brokerQueueName_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDurable
 * brokerQueueDurable is subid 3 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.3
 * Description:
Queue durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerQueueDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDurable_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                       u_long * brokerQueueDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDurable_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueDurable data.
     * copy (* brokerQueueDurable_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueDurable_val_ptr) = rowreq_ctx->data.brokerQueueDurable;

    return MFD_SUCCESS;
}                               /* brokerQueueDurable_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueAutoDelete
 * brokerQueueAutoDelete is subid 4 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.4
 * Description:
Queue autoDelete
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerQueueAutoDelete data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueAutoDelete_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueAutoDelete_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                          u_long * brokerQueueAutoDelete_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueAutoDelete_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueAutoDelete_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueAutoDelete data.
     * copy (* brokerQueueAutoDelete_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueAutoDelete_val_ptr) =
        rowreq_ctx->data.brokerQueueAutoDelete;

    return MFD_SUCCESS;
}                               /* brokerQueueAutoDelete_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueExclusive
 * brokerQueueExclusive is subid 5 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.5
 * Description:
Queue exclusive
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerQueueExclusive data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueExclusive_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueExclusive_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                         u_long * brokerQueueExclusive_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueExclusive_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueExclusive_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueExclusive data.
     * copy (* brokerQueueExclusive_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueExclusive_val_ptr) =
        rowreq_ctx->data.brokerQueueExclusive;

    return MFD_SUCCESS;
}                               /* brokerQueueExclusive_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueArguments
 * brokerQueueArguments is subid 6 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.6
 * Description:
Arguments supplied in queue.declare
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Map (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the brokerQueueArguments data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueArguments_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerQueueArguments_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerQueueArguments.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerQueueArguments_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerQueueArguments_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerQueueArguments_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                         char **brokerQueueArguments_val_ptr_ptr,
                         size_t *brokerQueueArguments_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerQueueArguments_val_ptr_ptr)
                   && (NULL != *brokerQueueArguments_val_ptr_ptr));
    netsnmp_assert(NULL != brokerQueueArguments_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueArguments_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueArguments data.
     * copy (* brokerQueueArguments_val_ptr_ptr ) data and (* brokerQueueArguments_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerQueueArguments data
     */
    if ((NULL == (*brokerQueueArguments_val_ptr_ptr)) ||
        ((*brokerQueueArguments_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerQueueArguments_len *
          sizeof(rowreq_ctx->data.brokerQueueArguments[0])))) {
        /*
         * allocate space for brokerQueueArguments data
         */
        (*brokerQueueArguments_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerQueueArguments_len *
                   sizeof(rowreq_ctx->data.brokerQueueArguments[0]));
        if (NULL == (*brokerQueueArguments_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerQueueArguments)\n");
            return MFD_ERROR;
        }
    }
    (*brokerQueueArguments_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerQueueArguments_len *
        sizeof(rowreq_ctx->data.brokerQueueArguments[0]);
    memcpy((*brokerQueueArguments_val_ptr_ptr),
           rowreq_ctx->data.brokerQueueArguments,
           rowreq_ctx->data.brokerQueueArguments_len *
           sizeof(rowreq_ctx->data.brokerQueueArguments[0]));

    return MFD_SUCCESS;
}                               /* brokerQueueArguments_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueAltExchange
 * brokerQueueAltExchange is subid 7 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.7
 * Description:
Queue altExchange
                     Additional info ( nodeType:property, references:Exchange, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerQueueAltExchange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueAltExchange_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerQueueAltExchange_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerQueueAltExchange.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerQueueAltExchange_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerQueueAltExchange_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerQueueAltExchange_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                           char **brokerQueueAltExchange_val_ptr_ptr,
                           size_t *brokerQueueAltExchange_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerQueueAltExchange_val_ptr_ptr)
                   && (NULL != *brokerQueueAltExchange_val_ptr_ptr));
    netsnmp_assert(NULL != brokerQueueAltExchange_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueAltExchange_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueAltExchange data.
     * copy (* brokerQueueAltExchange_val_ptr_ptr ) data and (* brokerQueueAltExchange_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerQueueAltExchange data
     */
    if ((NULL == (*brokerQueueAltExchange_val_ptr_ptr)) ||
        ((*brokerQueueAltExchange_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerQueueAltExchange_len *
          sizeof(rowreq_ctx->data.brokerQueueAltExchange[0])))) {
        /*
         * allocate space for brokerQueueAltExchange data
         */
        (*brokerQueueAltExchange_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerQueueAltExchange_len *
                   sizeof(rowreq_ctx->data.brokerQueueAltExchange[0]));
        if (NULL == (*brokerQueueAltExchange_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerQueueAltExchange)\n");
            return MFD_ERROR;
        }
    }
    (*brokerQueueAltExchange_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerQueueAltExchange_len *
        sizeof(rowreq_ctx->data.brokerQueueAltExchange[0]);
    memcpy((*brokerQueueAltExchange_val_ptr_ptr),
           rowreq_ctx->data.brokerQueueAltExchange,
           rowreq_ctx->data.brokerQueueAltExchange_len *
           sizeof(rowreq_ctx->data.brokerQueueAltExchange[0]));

    return MFD_SUCCESS;
}                               /* brokerQueueAltExchange_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgTotalEnqueues
 * brokerQueueMsgTotalEnqueues is subid 8 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.8
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgTotalEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * brokerQueueMsgTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgTotalEnqueues data.
     * get (* brokerQueueMsgTotalEnqueues_val_ptr ).low and (* brokerQueueMsgTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgTotalEnqueues.high;
    (*brokerQueueMsgTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgTotalEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgTotalDequeues
 * brokerQueueMsgTotalDequeues is subid 9 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.9
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgTotalDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * brokerQueueMsgTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgTotalDequeues data.
     * get (* brokerQueueMsgTotalDequeues_val_ptr ).low and (* brokerQueueMsgTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgTotalDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgTotalDequeues.high;
    (*brokerQueueMsgTotalDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgTotalDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgTxnEnqueues
 * brokerQueueMsgTxnEnqueues is subid 10 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.10
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgTxnEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * brokerQueueMsgTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgTxnEnqueues data.
     * get (* brokerQueueMsgTxnEnqueues_val_ptr ).low and (* brokerQueueMsgTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgTxnEnqueues.high;
    (*brokerQueueMsgTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgTxnEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgTxnDequeues
 * brokerQueueMsgTxnDequeues is subid 11 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.11
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgTxnDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * brokerQueueMsgTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgTxnDequeues data.
     * get (* brokerQueueMsgTxnDequeues_val_ptr ).low and (* brokerQueueMsgTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgTxnDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgTxnDequeues.high;
    (*brokerQueueMsgTxnDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgTxnDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgPersistEnqueues
 * brokerQueueMsgPersistEnqueues is subid 12 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.12
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgPersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgPersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgPersistEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  brokerQueueMsgPersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgPersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgPersistEnqueues data.
     * get (* brokerQueueMsgPersistEnqueues_val_ptr ).low and (* brokerQueueMsgPersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgPersistEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgPersistEnqueues.high;
    (*brokerQueueMsgPersistEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgPersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgPersistEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgPersistDequeues
 * brokerQueueMsgPersistDequeues is subid 13 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.13
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgPersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgPersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgPersistDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  brokerQueueMsgPersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgPersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgPersistDequeues data.
     * get (* brokerQueueMsgPersistDequeues_val_ptr ).low and (* brokerQueueMsgPersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgPersistDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgPersistDequeues.high;
    (*brokerQueueMsgPersistDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgPersistDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgPersistDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgDepth
 * brokerQueueMsgDepth is subid 14 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.14
 * Description:
Current size of queue in messages
                     Additional info ( nodeType:statistic, assign:msgTotalEnqueues - msgTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgDepth_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * brokerQueueMsgDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgDepth data.
     * get (* brokerQueueMsgDepth_val_ptr ).low and (* brokerQueueMsgDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgDepth_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgDepth.high;
    (*brokerQueueMsgDepth_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgDepth.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgDepth_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteDepth
 * brokerQueueByteDepth is subid 15 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.15
 * Description:
Current size of queue in bytes
                     Additional info ( nodeType:statistic, assign:byteTotalEnqueues - byteTotalDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteDepth_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                         U64 * brokerQueueByteDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteDepth data.
     * get (* brokerQueueByteDepth_val_ptr ).low and (* brokerQueueByteDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteDepth_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteDepth.high;
    (*brokerQueueByteDepth_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteDepth.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteDepth_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteTotalEnqueues
 * brokerQueueByteTotalEnqueues is subid 16 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.16
 * Description:
Total messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteTotalEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteTotalEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteTotalEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 brokerQueueByteTotalEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteTotalEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteTotalEnqueues data.
     * get (* brokerQueueByteTotalEnqueues_val_ptr ).low and (* brokerQueueByteTotalEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteTotalEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteTotalEnqueues.high;
    (*brokerQueueByteTotalEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteTotalEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteTotalEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteTotalDequeues
 * brokerQueueByteTotalDequeues is subid 17 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.17
 * Description:
Total messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteTotalDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteTotalDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteTotalDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                 U64 *
                                 brokerQueueByteTotalDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteTotalDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteTotalDequeues data.
     * get (* brokerQueueByteTotalDequeues_val_ptr ).low and (* brokerQueueByteTotalDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteTotalDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteTotalDequeues.high;
    (*brokerQueueByteTotalDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteTotalDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteTotalDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteTxnEnqueues
 * brokerQueueByteTxnEnqueues is subid 18 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.18
 * Description:
Transactional messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteTxnEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteTxnEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteTxnEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * brokerQueueByteTxnEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteTxnEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteTxnEnqueues data.
     * get (* brokerQueueByteTxnEnqueues_val_ptr ).low and (* brokerQueueByteTxnEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteTxnEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteTxnEnqueues.high;
    (*brokerQueueByteTxnEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteTxnEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteTxnEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteTxnDequeues
 * brokerQueueByteTxnDequeues is subid 19 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.19
 * Description:
Transactional messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteTxnDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteTxnDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteTxnDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * brokerQueueByteTxnDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteTxnDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteTxnDequeues data.
     * get (* brokerQueueByteTxnDequeues_val_ptr ).low and (* brokerQueueByteTxnDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteTxnDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteTxnDequeues.high;
    (*brokerQueueByteTxnDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteTxnDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteTxnDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueBytePersistEnqueues
 * brokerQueueBytePersistEnqueues is subid 20 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.20
 * Description:
Persistent messages enqueued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueBytePersistEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueBytePersistEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueBytePersistEnqueues_get(brokerQueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   brokerQueueBytePersistEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueBytePersistEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueBytePersistEnqueues data.
     * get (* brokerQueueBytePersistEnqueues_val_ptr ).low and (* brokerQueueBytePersistEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueBytePersistEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueBytePersistEnqueues.high;
    (*brokerQueueBytePersistEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueBytePersistEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueBytePersistEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueBytePersistDequeues
 * brokerQueueBytePersistDequeues is subid 21 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.21
 * Description:
Persistent messages dequeued
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueBytePersistDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueBytePersistDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueBytePersistDequeues_get(brokerQueueTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   brokerQueueBytePersistDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueBytePersistDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueBytePersistDequeues data.
     * get (* brokerQueueBytePersistDequeues_val_ptr ).low and (* brokerQueueBytePersistDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueBytePersistDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueBytePersistDequeues.high;
    (*brokerQueueBytePersistDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueBytePersistDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueBytePersistDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgFtdEnqueues
 * brokerQueueMsgFtdEnqueues is subid 22 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.22
 * Description:
Total message bodies released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgFtdEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * brokerQueueMsgFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgFtdEnqueues data.
     * get (* brokerQueueMsgFtdEnqueues_val_ptr ).low and (* brokerQueueMsgFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgFtdEnqueues.high;
    (*brokerQueueMsgFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgFtdEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgFtdDequeues
 * brokerQueueMsgFtdDequeues is subid 23 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.23
 * Description:
Total message bodies dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgFtdDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              U64 * brokerQueueMsgFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgFtdDequeues data.
     * get (* brokerQueueMsgFtdDequeues_val_ptr ).low and (* brokerQueueMsgFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgFtdDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgFtdDequeues.high;
    (*brokerQueueMsgFtdDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgFtdDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteFtdEnqueues
 * brokerQueueByteFtdEnqueues is subid 24 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.24
 * Description:
Total bytes released from memory and flowed-to-disk on broker
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteFtdEnqueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteFtdEnqueues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteFtdEnqueues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * brokerQueueByteFtdEnqueues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteFtdEnqueues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteFtdEnqueues data.
     * get (* brokerQueueByteFtdEnqueues_val_ptr ).low and (* brokerQueueByteFtdEnqueues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteFtdEnqueues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteFtdEnqueues.high;
    (*brokerQueueByteFtdEnqueues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteFtdEnqueues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteFtdEnqueues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteFtdDequeues
 * brokerQueueByteFtdDequeues is subid 25 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.25
 * Description:
Total bytes dequeued from the broker having been flowed-to-disk
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteFtdDequeues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteFtdDequeues_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteFtdDequeues_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               U64 * brokerQueueByteFtdDequeues_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteFtdDequeues_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteFtdDequeues data.
     * get (* brokerQueueByteFtdDequeues_val_ptr ).low and (* brokerQueueByteFtdDequeues_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteFtdDequeues_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteFtdDequeues.high;
    (*brokerQueueByteFtdDequeues_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteFtdDequeues.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteFtdDequeues_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMsgFtdDepth
 * brokerQueueMsgFtdDepth is subid 26 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.26
 * Description:
Current number of messages flowed-to-disk
                     Additional info ( nodeType:statistic, assign:msgFtdEnqueues - msgFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueMsgFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMsgFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMsgFtdDepth_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * brokerQueueMsgFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMsgFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueMsgFtdDepth data.
     * get (* brokerQueueMsgFtdDepth_val_ptr ).low and (* brokerQueueMsgFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueMsgFtdDepth_val_ptr).high =
        rowreq_ctx->data.brokerQueueMsgFtdDepth.high;
    (*brokerQueueMsgFtdDepth_val_ptr).low =
        rowreq_ctx->data.brokerQueueMsgFtdDepth.low;


    return MFD_SUCCESS;
}                               /* brokerQueueMsgFtdDepth_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueByteFtdDepth
 * brokerQueueByteFtdDepth is subid 27 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.27
 * Description:
Current number of bytes flowed-to-disk
                     Additional info ( nodeType:statistic, assign:byteFtdEnqueues - byteFtdDequeues )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueByteFtdDepth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueByteFtdDepth_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueByteFtdDepth_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * brokerQueueByteFtdDepth_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueByteFtdDepth_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueByteFtdDepth data.
     * get (* brokerQueueByteFtdDepth_val_ptr ).low and (* brokerQueueByteFtdDepth_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueByteFtdDepth_val_ptr).high =
        rowreq_ctx->data.brokerQueueByteFtdDepth.high;
    (*brokerQueueByteFtdDepth_val_ptr).low =
        rowreq_ctx->data.brokerQueueByteFtdDepth.low;


    return MFD_SUCCESS;
}                               /* brokerQueueByteFtdDepth_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueReleases
 * brokerQueueReleases is subid 28 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.28
 * Description:
Acquired messages reinserted into the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueReleases data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueReleases_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueReleases_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * brokerQueueReleases_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueReleases_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueReleases data.
     * get (* brokerQueueReleases_val_ptr ).low and (* brokerQueueReleases_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueReleases_val_ptr).high =
        rowreq_ctx->data.brokerQueueReleases.high;
    (*brokerQueueReleases_val_ptr).low =
        rowreq_ctx->data.brokerQueueReleases.low;


    return MFD_SUCCESS;
}                               /* brokerQueueReleases_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueAcquires
 * brokerQueueAcquires is subid 29 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.29
 * Description:
Messages acquired from the queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueAcquires data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueAcquires_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueAcquires_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * brokerQueueAcquires_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueAcquires_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueAcquires data.
     * get (* brokerQueueAcquires_val_ptr ).low and (* brokerQueueAcquires_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueAcquires_val_ptr).high =
        rowreq_ctx->data.brokerQueueAcquires.high;
    (*brokerQueueAcquires_val_ptr).low =
        rowreq_ctx->data.brokerQueueAcquires.low;


    return MFD_SUCCESS;
}                               /* brokerQueueAcquires_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsTtl
 * brokerQueueDiscardsTtl is subid 30 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.30
 * Description:
Messages discarded due to TTL expiration
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsTtl data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsTtl_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsTtl_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * brokerQueueDiscardsTtl_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsTtl_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsTtl data.
     * get (* brokerQueueDiscardsTtl_val_ptr ).low and (* brokerQueueDiscardsTtl_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsTtl_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsTtl.high;
    (*brokerQueueDiscardsTtl_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsTtl.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsTtl_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsRing
 * brokerQueueDiscardsRing is subid 31 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.31
 * Description:
Messages discarded due to ring-queue overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsRing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsRing_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsRing_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                            U64 * brokerQueueDiscardsRing_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsRing_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsRing data.
     * get (* brokerQueueDiscardsRing_val_ptr ).low and (* brokerQueueDiscardsRing_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsRing_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsRing.high;
    (*brokerQueueDiscardsRing_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsRing.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsRing_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsLvq
 * brokerQueueDiscardsLvq is subid 32 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.32
 * Description:
Messages discarded due to LVQ insert
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsLvq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsLvq_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsLvq_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                           U64 * brokerQueueDiscardsLvq_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsLvq_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsLvq data.
     * get (* brokerQueueDiscardsLvq_val_ptr ).low and (* brokerQueueDiscardsLvq_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsLvq_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsLvq.high;
    (*brokerQueueDiscardsLvq_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsLvq.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsLvq_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsOverflow
 * brokerQueueDiscardsOverflow is subid 33 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.33
 * Description:
Messages discarded due to reject-policy overflow
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsOverflow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsOverflow_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsOverflow_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                U64 * brokerQueueDiscardsOverflow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsOverflow_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsOverflow data.
     * get (* brokerQueueDiscardsOverflow_val_ptr ).low and (* brokerQueueDiscardsOverflow_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsOverflow_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsOverflow.high;
    (*brokerQueueDiscardsOverflow_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsOverflow.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsOverflow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsSubscriber
 * brokerQueueDiscardsSubscriber is subid 34 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.34
 * Description:
Messages discarded due to subscriber reject
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsSubscriber data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsSubscriber_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsSubscriber_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                  U64 *
                                  brokerQueueDiscardsSubscriber_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsSubscriber_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsSubscriber data.
     * get (* brokerQueueDiscardsSubscriber_val_ptr ).low and (* brokerQueueDiscardsSubscriber_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsSubscriber_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsSubscriber.high;
    (*brokerQueueDiscardsSubscriber_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsSubscriber.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsSubscriber_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueDiscardsPurge
 * brokerQueueDiscardsPurge is subid 35 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.35
 * Description:
Messages discarded due to management purge
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueDiscardsPurge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueDiscardsPurge_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueDiscardsPurge_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                             U64 * brokerQueueDiscardsPurge_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueDiscardsPurge_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueDiscardsPurge data.
     * get (* brokerQueueDiscardsPurge_val_ptr ).low and (* brokerQueueDiscardsPurge_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueDiscardsPurge_val_ptr).high =
        rowreq_ctx->data.brokerQueueDiscardsPurge.high;
    (*brokerQueueDiscardsPurge_val_ptr).low =
        rowreq_ctx->data.brokerQueueDiscardsPurge.low;


    return MFD_SUCCESS;
}                               /* brokerQueueDiscardsPurge_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueReroutes
 * brokerQueueReroutes is subid 36 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.36
 * Description:
Messages dequeued to management re-route
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerQueueReroutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueReroutes_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueReroutes_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                        U64 * brokerQueueReroutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueReroutes_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerQueueReroutes data.
     * get (* brokerQueueReroutes_val_ptr ).low and (* brokerQueueReroutes_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerQueueReroutes_val_ptr).high =
        rowreq_ctx->data.brokerQueueReroutes.high;
    (*brokerQueueReroutes_val_ptr).low =
        rowreq_ctx->data.brokerQueueReroutes.low;


    return MFD_SUCCESS;
}                               /* brokerQueueReroutes_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueConsumerCount
 * brokerQueueConsumerCount is subid 37 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.37
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueConsumerCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueConsumerCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueConsumerCount_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                             long *brokerQueueConsumerCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueConsumerCount_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueConsumerCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueConsumerCount data.
     * copy (* brokerQueueConsumerCount_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueConsumerCount_val_ptr) =
        rowreq_ctx->data.brokerQueueConsumerCount;

    return MFD_SUCCESS;
}                               /* brokerQueueConsumerCount_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueConsumerCountHi
 * brokerQueueConsumerCountHi is subid 38 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.38
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueConsumerCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueConsumerCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueConsumerCountHi_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               long *brokerQueueConsumerCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueConsumerCountHi_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueConsumerCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueConsumerCountHi data.
     * copy (* brokerQueueConsumerCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueConsumerCountHi_val_ptr) =
        rowreq_ctx->data.brokerQueueConsumerCountHi;

    return MFD_SUCCESS;
}                               /* brokerQueueConsumerCountHi_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueConsumerCountLow
 * brokerQueueConsumerCountLow is subid 39 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.39
 * Description:
Current consumers on queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueConsumerCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueConsumerCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueConsumerCountLow_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                long *brokerQueueConsumerCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueConsumerCountLow_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueConsumerCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueConsumerCountLow data.
     * copy (* brokerQueueConsumerCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueConsumerCountLow_val_ptr) =
        rowreq_ctx->data.brokerQueueConsumerCountLow;

    return MFD_SUCCESS;
}                               /* brokerQueueConsumerCountLow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueBindingCount
 * brokerQueueBindingCount is subid 40 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.40
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueBindingCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueBindingCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueBindingCount_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                            long *brokerQueueBindingCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueBindingCount_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueBindingCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueBindingCount data.
     * copy (* brokerQueueBindingCount_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueBindingCount_val_ptr) =
        rowreq_ctx->data.brokerQueueBindingCount;

    return MFD_SUCCESS;
}                               /* brokerQueueBindingCount_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueBindingCountHi
 * brokerQueueBindingCountHi is subid 41 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.41
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueBindingCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueBindingCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueBindingCountHi_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              long *brokerQueueBindingCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueBindingCountHi_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueBindingCountHi_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueBindingCountHi data.
     * copy (* brokerQueueBindingCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueBindingCountHi_val_ptr) =
        rowreq_ctx->data.brokerQueueBindingCountHi;

    return MFD_SUCCESS;
}                               /* brokerQueueBindingCountHi_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueBindingCountLow
 * brokerQueueBindingCountLow is subid 42 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.42
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueBindingCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueBindingCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueBindingCountLow_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               long *brokerQueueBindingCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueBindingCountLow_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueBindingCountLow_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueBindingCountLow data.
     * copy (* brokerQueueBindingCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueBindingCountLow_val_ptr) =
        rowreq_ctx->data.brokerQueueBindingCountLow;

    return MFD_SUCCESS;
}                               /* brokerQueueBindingCountLow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueUnackedMessages
 * brokerQueueUnackedMessages is subid 43 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.43
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueUnackedMessages data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueUnackedMessages_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueUnackedMessages_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                               long *brokerQueueUnackedMessages_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueUnackedMessages_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueUnackedMessages_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueUnackedMessages data.
     * copy (* brokerQueueUnackedMessages_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueUnackedMessages_val_ptr) =
        rowreq_ctx->data.brokerQueueUnackedMessages;

    return MFD_SUCCESS;
}                               /* brokerQueueUnackedMessages_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueUnackedMessagesHi
 * brokerQueueUnackedMessagesHi is subid 44 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.44
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueUnackedMessagesHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueUnackedMessagesHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueUnackedMessagesHi_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                 long
                                 *brokerQueueUnackedMessagesHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueUnackedMessagesHi_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueUnackedMessagesHi_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueUnackedMessagesHi data.
     * copy (* brokerQueueUnackedMessagesHi_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueUnackedMessagesHi_val_ptr) =
        rowreq_ctx->data.brokerQueueUnackedMessagesHi;

    return MFD_SUCCESS;
}                               /* brokerQueueUnackedMessagesHi_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueUnackedMessagesLow
 * brokerQueueUnackedMessagesLow is subid 45 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.45
 * Description:
Messages consumed but not yet acked
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerQueueUnackedMessagesLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueUnackedMessagesLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueUnackedMessagesLow_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                  long
                                  *brokerQueueUnackedMessagesLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueUnackedMessagesLow_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueUnackedMessagesLow_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueUnackedMessagesLow data.
     * copy (* brokerQueueUnackedMessagesLow_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueUnackedMessagesLow_val_ptr) =
        rowreq_ctx->data.brokerQueueUnackedMessagesLow;

    return MFD_SUCCESS;
}                               /* brokerQueueUnackedMessagesLow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueMessageLatency
 * brokerQueueMessageLatency is subid 46 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.46
 * Description:
Broker latency through this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the brokerQueueMessageLatency data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueMessageLatency_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueMessageLatency_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                              u_long * brokerQueueMessageLatency_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueMessageLatency_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueMessageLatency_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueMessageLatency data.
     * copy (* brokerQueueMessageLatency_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueMessageLatency_val_ptr) =
        rowreq_ctx->data.brokerQueueMessageLatency;

    return MFD_SUCCESS;
}                               /* brokerQueueMessageLatency_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueFlowStopped
 * brokerQueueFlowStopped is subid 47 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.47
 * Description:
Flow control active.
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerQueueFlowStopped data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueFlowStopped_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueFlowStopped_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                           u_long * brokerQueueFlowStopped_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueFlowStopped_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueFlowStopped_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueFlowStopped data.
     * copy (* brokerQueueFlowStopped_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueFlowStopped_val_ptr) =
        rowreq_ctx->data.brokerQueueFlowStopped;

    return MFD_SUCCESS;
}                               /* brokerQueueFlowStopped_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerQueueEntry.brokerQueueFlowStoppedCount
 * brokerQueueFlowStoppedCount is subid 48 of brokerQueueEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.6.1.1.48
 * Description:
Number of times flow control was activated for this queue
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the brokerQueueFlowStoppedCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerQueueFlowStoppedCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerQueueFlowStoppedCount_get(brokerQueueTable_rowreq_ctx * rowreq_ctx,
                                u_long *
                                brokerQueueFlowStoppedCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerQueueFlowStoppedCount_val_ptr);


    DEBUGMSGTL(("verbose:brokerQueueTable:brokerQueueFlowStoppedCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerQueueFlowStoppedCount data.
     * copy (* brokerQueueFlowStoppedCount_val_ptr ) from rowreq_ctx->data
     */
    (*brokerQueueFlowStoppedCount_val_ptr) =
        rowreq_ctx->data.brokerQueueFlowStoppedCount;

    return MFD_SUCCESS;
}                               /* brokerQueueFlowStoppedCount_get */



/** @} */
