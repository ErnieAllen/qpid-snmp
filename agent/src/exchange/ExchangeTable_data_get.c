/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ExchangeTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement brokerExchangeTable get routines.
 * TODO:240:M: Implement brokerExchangeTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table brokerExchangeTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * QPID-MESSAGING-MIB::brokerExchangeTable is subid 1 of brokerExchanges.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement brokerExchangeTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param brokerExchangeInternalIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
brokerExchangeTable_indexes_set_tbl_idx(brokerExchangeTable_mib_index *
                                        tbl_idx,
                                        u_long
                                        brokerExchangeInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeTable_indexes_set_tbl_idx", "called\n"));

    /*
     * brokerExchangeInternalIndex(20)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->brokerExchangeInternalIndex = brokerExchangeInternalIndex_val;


    return MFD_SUCCESS;
}                               /* brokerExchangeTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
brokerExchangeTable_indexes_set(brokerExchangeTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long brokerExchangeInternalIndex_val)
{
    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        brokerExchangeTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                brokerExchangeInternalIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != brokerExchangeTable_index_to_oid(&rowreq_ctx->oid_idx,
                                              &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* brokerExchangeTable_indexes_set */


/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeVhostRef
 * brokerExchangeVhostRef is subid 1 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.1
 * Description:
Exchange vhostRef
                     Additional info ( nodeType:property, references:Vhost, index:y, parentRef:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerExchangeVhostRef data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeVhostRef_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerExchangeVhostRef_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerExchangeVhostRef.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerExchangeVhostRef_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerExchangeVhostRef_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerExchangeVhostRef_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                           char **brokerExchangeVhostRef_val_ptr_ptr,
                           size_t *brokerExchangeVhostRef_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerExchangeVhostRef_val_ptr_ptr)
                   && (NULL != *brokerExchangeVhostRef_val_ptr_ptr));
    netsnmp_assert(NULL != brokerExchangeVhostRef_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeVhostRef_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeVhostRef data.
     * copy (* brokerExchangeVhostRef_val_ptr_ptr ) data and (* brokerExchangeVhostRef_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerExchangeVhostRef data
     */
    if ((NULL == (*brokerExchangeVhostRef_val_ptr_ptr)) ||
        ((*brokerExchangeVhostRef_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerExchangeVhostRef_len *
          sizeof(rowreq_ctx->data.brokerExchangeVhostRef[0])))) {
        /*
         * allocate space for brokerExchangeVhostRef data
         */
        (*brokerExchangeVhostRef_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerExchangeVhostRef_len *
                   sizeof(rowreq_ctx->data.brokerExchangeVhostRef[0]));
        if (NULL == (*brokerExchangeVhostRef_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerExchangeVhostRef)\n");
            return MFD_ERROR;
        }
    }
    (*brokerExchangeVhostRef_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerExchangeVhostRef_len *
        sizeof(rowreq_ctx->data.brokerExchangeVhostRef[0]);
    memcpy((*brokerExchangeVhostRef_val_ptr_ptr),
           rowreq_ctx->data.brokerExchangeVhostRef,
           rowreq_ctx->data.brokerExchangeVhostRef_len *
           sizeof(rowreq_ctx->data.brokerExchangeVhostRef[0]));

    return MFD_SUCCESS;
}                               /* brokerExchangeVhostRef_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeName
 * brokerExchangeName is subid 2 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.2
 * Description:
Exchange name
                     Additional info ( nodeType:property, index:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerExchangeName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerExchangeName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerExchangeName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerExchangeName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerExchangeName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerExchangeName_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                       char **brokerExchangeName_val_ptr_ptr,
                       size_t *brokerExchangeName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerExchangeName_val_ptr_ptr)
                   && (NULL != *brokerExchangeName_val_ptr_ptr));
    netsnmp_assert(NULL != brokerExchangeName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeName_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeName data.
     * copy (* brokerExchangeName_val_ptr_ptr ) data and (* brokerExchangeName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerExchangeName data
     */
    if ((NULL == (*brokerExchangeName_val_ptr_ptr)) ||
        ((*brokerExchangeName_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerExchangeName_len *
          sizeof(rowreq_ctx->data.brokerExchangeName[0])))) {
        /*
         * allocate space for brokerExchangeName data
         */
        (*brokerExchangeName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerExchangeName_len *
                   sizeof(rowreq_ctx->data.brokerExchangeName[0]));
        if (NULL == (*brokerExchangeName_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerExchangeName)\n");
            return MFD_ERROR;
        }
    }
    (*brokerExchangeName_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerExchangeName_len *
        sizeof(rowreq_ctx->data.brokerExchangeName[0]);
    memcpy((*brokerExchangeName_val_ptr_ptr),
           rowreq_ctx->data.brokerExchangeName,
           rowreq_ctx->data.brokerExchangeName_len *
           sizeof(rowreq_ctx->data.brokerExchangeName[0]));

    return MFD_SUCCESS;
}                               /* brokerExchangeName_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeType
 * brokerExchangeType is subid 3 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.3
 * Description:
Exchange type
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is Sstr (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerExchangeType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeType_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerExchangeType_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerExchangeType.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerExchangeType_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerExchangeType_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerExchangeType_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                       char **brokerExchangeType_val_ptr_ptr,
                       size_t *brokerExchangeType_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerExchangeType_val_ptr_ptr)
                   && (NULL != *brokerExchangeType_val_ptr_ptr));
    netsnmp_assert(NULL != brokerExchangeType_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeType_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeType data.
     * copy (* brokerExchangeType_val_ptr_ptr ) data and (* brokerExchangeType_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerExchangeType data
     */
    if ((NULL == (*brokerExchangeType_val_ptr_ptr)) ||
        ((*brokerExchangeType_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerExchangeType_len *
          sizeof(rowreq_ctx->data.brokerExchangeType[0])))) {
        /*
         * allocate space for brokerExchangeType data
         */
        (*brokerExchangeType_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerExchangeType_len *
                   sizeof(rowreq_ctx->data.brokerExchangeType[0]));
        if (NULL == (*brokerExchangeType_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerExchangeType)\n");
            return MFD_ERROR;
        }
    }
    (*brokerExchangeType_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerExchangeType_len *
        sizeof(rowreq_ctx->data.brokerExchangeType[0]);
    memcpy((*brokerExchangeType_val_ptr_ptr),
           rowreq_ctx->data.brokerExchangeType,
           rowreq_ctx->data.brokerExchangeType_len *
           sizeof(rowreq_ctx->data.brokerExchangeType[0]));

    return MFD_SUCCESS;
}                               /* brokerExchangeType_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeDurable
 * brokerExchangeDurable is subid 4 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.4
 * Description:
Exchange durable
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerExchangeDurable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeDurable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeDurable_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                          u_long * brokerExchangeDurable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeDurable_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeDurable_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeDurable data.
     * copy (* brokerExchangeDurable_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeDurable_val_ptr) =
        rowreq_ctx->data.brokerExchangeDurable;

    return MFD_SUCCESS;
}                               /* brokerExchangeDurable_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeAutoDelete
 * brokerExchangeAutoDelete is subid 5 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.5
 * Description:
Exchange autoDelete
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the brokerExchangeAutoDelete data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeAutoDelete_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeAutoDelete_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                             u_long * brokerExchangeAutoDelete_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeAutoDelete_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeAutoDelete_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeAutoDelete data.
     * copy (* brokerExchangeAutoDelete_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeAutoDelete_val_ptr) =
        rowreq_ctx->data.brokerExchangeAutoDelete;

    return MFD_SUCCESS;
}                               /* brokerExchangeAutoDelete_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeAltExchange
 * brokerExchangeAltExchange is subid 6 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.6
 * Description:
Exchange altExchange
                     Additional info ( nodeType:property, references:Exchange, optional:y )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is ObjId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the brokerExchangeAltExchange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeAltExchange_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerExchangeAltExchange_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerExchangeAltExchange.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerExchangeAltExchange_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerExchangeAltExchange_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerExchangeAltExchange_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                              char **brokerExchangeAltExchange_val_ptr_ptr,
                              size_t
                              *brokerExchangeAltExchange_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerExchangeAltExchange_val_ptr_ptr)
                   && (NULL != *brokerExchangeAltExchange_val_ptr_ptr));
    netsnmp_assert(NULL != brokerExchangeAltExchange_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeAltExchange_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeAltExchange data.
     * copy (* brokerExchangeAltExchange_val_ptr_ptr ) data and (* brokerExchangeAltExchange_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerExchangeAltExchange data
     */
    if ((NULL == (*brokerExchangeAltExchange_val_ptr_ptr)) ||
        ((*brokerExchangeAltExchange_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerExchangeAltExchange_len *
          sizeof(rowreq_ctx->data.brokerExchangeAltExchange[0])))) {
        /*
         * allocate space for brokerExchangeAltExchange data
         */
        (*brokerExchangeAltExchange_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerExchangeAltExchange_len *
                   sizeof(rowreq_ctx->data.brokerExchangeAltExchange[0]));
        if (NULL == (*brokerExchangeAltExchange_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerExchangeAltExchange)\n");
            return MFD_ERROR;
        }
    }
    (*brokerExchangeAltExchange_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerExchangeAltExchange_len *
        sizeof(rowreq_ctx->data.brokerExchangeAltExchange[0]);
    memcpy((*brokerExchangeAltExchange_val_ptr_ptr),
           rowreq_ctx->data.brokerExchangeAltExchange,
           rowreq_ctx->data.brokerExchangeAltExchange_len *
           sizeof(rowreq_ctx->data.brokerExchangeAltExchange[0]));

    return MFD_SUCCESS;
}                               /* brokerExchangeAltExchange_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeArguments
 * brokerExchangeArguments is subid 7 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.7
 * Description:
Arguments supplied in exchange.declare
                     Additional info ( nodeType:property )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 65535a
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is Map (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the brokerExchangeArguments data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeArguments_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param brokerExchangeArguments_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by brokerExchangeArguments.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*brokerExchangeArguments_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update brokerExchangeArguments_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
brokerExchangeArguments_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                            char **brokerExchangeArguments_val_ptr_ptr,
                            size_t
                            *brokerExchangeArguments_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != brokerExchangeArguments_val_ptr_ptr)
                   && (NULL != *brokerExchangeArguments_val_ptr_ptr));
    netsnmp_assert(NULL != brokerExchangeArguments_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeArguments_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeArguments data.
     * copy (* brokerExchangeArguments_val_ptr_ptr ) data and (* brokerExchangeArguments_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for brokerExchangeArguments data
     */
    if ((NULL == (*brokerExchangeArguments_val_ptr_ptr)) ||
        ((*brokerExchangeArguments_val_ptr_len_ptr) <
         (rowreq_ctx->data.brokerExchangeArguments_len *
          sizeof(rowreq_ctx->data.brokerExchangeArguments[0])))) {
        /*
         * allocate space for brokerExchangeArguments data
         */
        (*brokerExchangeArguments_val_ptr_ptr) =
            malloc(rowreq_ctx->data.brokerExchangeArguments_len *
                   sizeof(rowreq_ctx->data.brokerExchangeArguments[0]));
        if (NULL == (*brokerExchangeArguments_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.brokerExchangeArguments)\n");
            return MFD_ERROR;
        }
    }
    (*brokerExchangeArguments_val_ptr_len_ptr) =
        rowreq_ctx->data.brokerExchangeArguments_len *
        sizeof(rowreq_ctx->data.brokerExchangeArguments[0]);
    memcpy((*brokerExchangeArguments_val_ptr_ptr),
           rowreq_ctx->data.brokerExchangeArguments,
           rowreq_ctx->data.brokerExchangeArguments_len *
           sizeof(rowreq_ctx->data.brokerExchangeArguments[0]));

    return MFD_SUCCESS;
}                               /* brokerExchangeArguments_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeProducerCount
 * brokerExchangeProducerCount is subid 8 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.8
 * Description:
Current producers on exchange
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeProducerCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeProducerCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeProducerCount_get(brokerExchangeTable_rowreq_ctx *
                                rowreq_ctx,
                                long *brokerExchangeProducerCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeProducerCount_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeProducerCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeProducerCount data.
     * copy (* brokerExchangeProducerCount_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeProducerCount_val_ptr) =
        rowreq_ctx->data.brokerExchangeProducerCount;

    return MFD_SUCCESS;
}                               /* brokerExchangeProducerCount_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeProducerCountHi
 * brokerExchangeProducerCountHi is subid 9 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.9
 * Description:
Current producers on exchange
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeProducerCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeProducerCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeProducerCountHi_get(brokerExchangeTable_rowreq_ctx *
                                  rowreq_ctx,
                                  long
                                  *brokerExchangeProducerCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeProducerCountHi_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeProducerCountHi_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeProducerCountHi data.
     * copy (* brokerExchangeProducerCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeProducerCountHi_val_ptr) =
        rowreq_ctx->data.brokerExchangeProducerCountHi;

    return MFD_SUCCESS;
}                               /* brokerExchangeProducerCountHi_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeProducerCountLow
 * brokerExchangeProducerCountLow is subid 10 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.10
 * Description:
Current producers on exchange
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeProducerCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeProducerCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeProducerCountLow_get(brokerExchangeTable_rowreq_ctx *
                                   rowreq_ctx,
                                   long
                                   *brokerExchangeProducerCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeProducerCountLow_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeProducerCountLow_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeProducerCountLow data.
     * copy (* brokerExchangeProducerCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeProducerCountLow_val_ptr) =
        rowreq_ctx->data.brokerExchangeProducerCountLow;

    return MFD_SUCCESS;
}                               /* brokerExchangeProducerCountLow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeBindingCount
 * brokerExchangeBindingCount is subid 11 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.11
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeBindingCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeBindingCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeBindingCount_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                               long *brokerExchangeBindingCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeBindingCount_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeBindingCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeBindingCount data.
     * copy (* brokerExchangeBindingCount_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeBindingCount_val_ptr) =
        rowreq_ctx->data.brokerExchangeBindingCount;

    return MFD_SUCCESS;
}                               /* brokerExchangeBindingCount_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeBindingCountHi
 * brokerExchangeBindingCountHi is subid 12 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.12
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeBindingCountHi data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeBindingCountHi_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeBindingCountHi_get(brokerExchangeTable_rowreq_ctx *
                                 rowreq_ctx,
                                 long
                                 *brokerExchangeBindingCountHi_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeBindingCountHi_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeBindingCountHi_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeBindingCountHi data.
     * copy (* brokerExchangeBindingCountHi_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeBindingCountHi_val_ptr) =
        rowreq_ctx->data.brokerExchangeBindingCountHi;

    return MFD_SUCCESS;
}                               /* brokerExchangeBindingCountHi_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeBindingCountLow
 * brokerExchangeBindingCountLow is subid 13 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.13
 * Description:
Current bindings
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: d
 *
 *
 * Its syntax is Hilo32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the brokerExchangeBindingCountLow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeBindingCountLow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeBindingCountLow_get(brokerExchangeTable_rowreq_ctx *
                                  rowreq_ctx,
                                  long
                                  *brokerExchangeBindingCountLow_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeBindingCountLow_val_ptr);


    DEBUGMSGTL(("verbose:brokerExchangeTable:brokerExchangeBindingCountLow_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the brokerExchangeBindingCountLow data.
     * copy (* brokerExchangeBindingCountLow_val_ptr ) from rowreq_ctx->data
     */
    (*brokerExchangeBindingCountLow_val_ptr) =
        rowreq_ctx->data.brokerExchangeBindingCountLow;

    return MFD_SUCCESS;
}                               /* brokerExchangeBindingCountLow_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeMsgReceives
 * brokerExchangeMsgReceives is subid 14 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.14
 * Description:
Total messages received
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeMsgReceives data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeMsgReceives_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeMsgReceives_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                              U64 * brokerExchangeMsgReceives_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeMsgReceives_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeMsgReceives data.
     * get (* brokerExchangeMsgReceives_val_ptr ).low and (* brokerExchangeMsgReceives_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeMsgReceives_val_ptr).high =
        rowreq_ctx->data.brokerExchangeMsgReceives.high;
    (*brokerExchangeMsgReceives_val_ptr).low =
        rowreq_ctx->data.brokerExchangeMsgReceives.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeMsgReceives_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeMsgDrops
 * brokerExchangeMsgDrops is subid 15 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.15
 * Description:
Total messages dropped (no matching key)
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeMsgDrops data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeMsgDrops_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeMsgDrops_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                           U64 * brokerExchangeMsgDrops_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeMsgDrops_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeMsgDrops data.
     * get (* brokerExchangeMsgDrops_val_ptr ).low and (* brokerExchangeMsgDrops_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeMsgDrops_val_ptr).high =
        rowreq_ctx->data.brokerExchangeMsgDrops.high;
    (*brokerExchangeMsgDrops_val_ptr).low =
        rowreq_ctx->data.brokerExchangeMsgDrops.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeMsgDrops_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeMsgRoutes
 * brokerExchangeMsgRoutes is subid 16 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.16
 * Description:
Total routed messages
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeMsgRoutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeMsgRoutes_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeMsgRoutes_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                            U64 * brokerExchangeMsgRoutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeMsgRoutes_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeMsgRoutes data.
     * get (* brokerExchangeMsgRoutes_val_ptr ).low and (* brokerExchangeMsgRoutes_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeMsgRoutes_val_ptr).high =
        rowreq_ctx->data.brokerExchangeMsgRoutes.high;
    (*brokerExchangeMsgRoutes_val_ptr).low =
        rowreq_ctx->data.brokerExchangeMsgRoutes.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeMsgRoutes_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeByteReceives
 * brokerExchangeByteReceives is subid 17 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.17
 * Description:
Total bytes received
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeByteReceives data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeByteReceives_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeByteReceives_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                               U64 * brokerExchangeByteReceives_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeByteReceives_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeByteReceives data.
     * get (* brokerExchangeByteReceives_val_ptr ).low and (* brokerExchangeByteReceives_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeByteReceives_val_ptr).high =
        rowreq_ctx->data.brokerExchangeByteReceives.high;
    (*brokerExchangeByteReceives_val_ptr).low =
        rowreq_ctx->data.brokerExchangeByteReceives.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeByteReceives_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeByteDrops
 * brokerExchangeByteDrops is subid 18 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.18
 * Description:
Total bytes dropped (no matching key)
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeByteDrops data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeByteDrops_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeByteDrops_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                            U64 * brokerExchangeByteDrops_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeByteDrops_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeByteDrops data.
     * get (* brokerExchangeByteDrops_val_ptr ).low and (* brokerExchangeByteDrops_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeByteDrops_val_ptr).high =
        rowreq_ctx->data.brokerExchangeByteDrops.high;
    (*brokerExchangeByteDrops_val_ptr).low =
        rowreq_ctx->data.brokerExchangeByteDrops.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeByteDrops_get */

/*---------------------------------------------------------------------
 * QPID-MESSAGING-MIB::brokerExchangeEntry.brokerExchangeByteRoutes
 * brokerExchangeByteRoutes is subid 19 of brokerExchangeEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.18060.5672.1.1.7.1.1.19
 * Description:
Total routed bytes
                     Additional info ( nodeType:statistic )
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the brokerExchangeByteRoutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param brokerExchangeByteRoutes_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
brokerExchangeByteRoutes_get(brokerExchangeTable_rowreq_ctx * rowreq_ctx,
                             U64 * brokerExchangeByteRoutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != brokerExchangeByteRoutes_val_ptr);

    /*
     * TODO:231:o: |-> copy brokerExchangeByteRoutes data.
     * get (* brokerExchangeByteRoutes_val_ptr ).low and (* brokerExchangeByteRoutes_val_ptr ).high from rowreq_ctx->data
     */
    (*brokerExchangeByteRoutes_val_ptr).high =
        rowreq_ctx->data.brokerExchangeByteRoutes.high;
    (*brokerExchangeByteRoutes_val_ptr).low =
        rowreq_ctx->data.brokerExchangeByteRoutes.low;


    return MFD_SUCCESS;
}                               /* brokerExchangeByteRoutes_get */



/** @} */
